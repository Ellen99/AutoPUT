/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.math4.linear;

import java.util.Arrays;
import java.util.Random;

import org.apache.commons.math4.distribution.RealDistribution;
import org.apache.commons.math4.distribution.NormalDistribution;
import org.apache.commons.math4.exception.MathUnsupportedOperationException;
import org.apache.commons.math4.linear.ArrayRealVector;
import org.apache.commons.math4.linear.EigenDecomposition;
import org.apache.commons.math4.linear.LUDecomposition;
import org.apache.commons.math4.linear.MatrixUtils;
import org.apache.commons.math4.linear.RealMatrix;
import org.apache.commons.math4.linear.RealVector;
import org.apache.commons.math4.linear.TriDiagonalTransformer;
import org.apache.commons.math4.util.FastMath;
import org.apache.commons.math4.util.MathArrays;
import org.apache.commons.numbers.core.Precision;
import org.apache.commons.rng.simple.RandomSource;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.experimental.theories.Theories;
import org.junit.experimental.theories.Theory;
import org.junit.experimental.theories.DataPoints;

public @RunWith(Theories.class) class AutoPutTest {

    private double[] refValues;
    private RealMatrix matrix;

    @Theory
	public void autoPutTest(Fixture fixture) {

        double[] mainTridiagonal = {
              fixture._input[0], fixture._input[1], fixture._input[2],
             fixture._input[3], fixture._input[4], fixture._input[5],
                fixture._input[6]
        };
        double[] secondaryTridiagonal = {
             fixture._input[7],fixture._input[8],fixture._input[9],
              fixture._input[10],fixture._input[11],fixture._input[12]
        };

        // the reference values have been computed using routine DSTEMR
        // from the fortran library LAPACK version 3.2.1
        double[] refEigenValues = {
                fixture._input[13],fixture._input[14],
                fixture._input[15],fixture._input[16],
                fixture._input[17],fixture._input[18],
                fixture._input[19]
        };
        RealVector[] refEigenVectors = {
                new ArrayRealVector(new double[] {fixture._input[20], fixture._input[21], fixture._input[22], fixture._input[23], fixture._input[24], fixture._input[25], fixture._input[26]}),
                new ArrayRealVector(new double[] {fixture._input[27],fixture._input[28],fixture._input[29],fixture._input[30],fixture._input[31],fixture._input[32],fixture._input[33]}),
                new ArrayRealVector(new double[] {fixture._input[34],fixture._input[35],fixture._input[36],fixture._input[37],fixture._input[38],fixture._input[39],fixture._input[40]}),
                new ArrayRealVector(new double[] {fixture._input[41],fixture._input[42],fixture._input[43],fixture._input[44],fixture._input[45],fixture._input[46],fixture._input[47]}),
                new ArrayRealVector(new double[] {fixture._input[48],fixture._input[49],fixture._input[50],fixture._input[51],fixture._input[52],fixture._input[53],fixture._input[54]}),
                new ArrayRealVector(new double[] {fixture._input[55],fixture._input[56],fixture._input[57],fixture._input[58],fixture._input[59],fixture._input[60],fixture._input[61]}),
                new ArrayRealVector(new double[] {fixture._input[62],fixture._input[63],fixture._input[64],fixture._input[65],fixture._input[66],fixture._input[67],fixture._input[68]})
        };

        // the following line triggers the exception
        EigenDecomposition decomposition;
        decomposition = new EigenDecomposition(mainTridiagonal, secondaryTridiagonal);

        double[] eigenValues = decomposition.getRealEigenvalues();
        for (int i = 0; i < refEigenValues.length; ++i) {
            Assert.assertEquals(refEigenValues[i], eigenValues[i], fixture._input[69]);
            if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) < 0) {
                Assert.assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);
            } else {
                Assert.assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);
            }
        }

    }

    /**
     * Checks that the eigen decomposition of a general (unsymmetric) matrix is valid by
     * checking: A*V = V*D
     */
    private void checkUnsymmetricMatrix(final RealMatrix m) {
        try {
            EigenDecomposition ed = new EigenDecomposition(m);

            RealMatrix d = ed.getD();
            RealMatrix v = ed.getV();
            //RealMatrix vT = ed.getVT();

            RealMatrix x = m.multiply(v);
            RealMatrix y = v.multiply(d);

            double diffNorm = x.subtract(y).getNorm();
            Assert.assertTrue("The norm of (X-Y) is too large: " + diffNorm + ", matrix=" + m.toString(),
                    x.subtract(y).getNorm() < 1000 * Precision.EPSILON * FastMath.max(x.getNorm(), y.getNorm()));

            RealMatrix invV = new LUDecomposition(v).getSolver().getInverse();
            double norm = v.multiply(d).multiply(invV).subtract(m).getNorm();
            Assert.assertEquals(0.0, norm, 1.0e-10);
        } catch (Exception e) {
            Assert.fail("Failed to create EigenDecomposition for matrix " + m.toString() + ", ex=" + e.toString());
        }
    }

    /**
     * Verifies that the given EigenDecomposition has eigenvalues equivalent to
     * the targetValues, ignoring the order of the values and allowing
     * values to differ by tolerance.
     */
    protected void checkEigenValues(double[] targetValues,
            EigenDecomposition ed, double tolerance) {
        double[] observed = ed.getRealEigenvalues();
        for (int i = 0; i < observed.length; i++) {
            Assert.assertTrue(isIncludedValue(observed[i], targetValues, tolerance));
            Assert.assertTrue(isIncludedValue(targetValues[i], observed, tolerance));
        }
    }


    /**
     * Returns true iff there is an entry within tolerance of value in
     * searchArray.
     */
    private boolean isIncludedValue(double value, double[] searchArray,
            double tolerance) {
       boolean found = false;
       int i = 0;
       while (!found && i < searchArray.length) {
           if (FastMath.abs(value - searchArray[i]) < tolerance) {
               found = true;
           }
           i++;
       }
       return found;
    }

    /**
     * Returns true iff eigenVector is a scalar multiple of one of the columns
     * of ed.getV().  Does not try linear combinations - i.e., should only be
     * used to find vectors in one-dimensional eigenspaces.
     */
    protected void checkEigenVector(double[] eigenVector,
            EigenDecomposition ed, double tolerance) {
        Assert.assertTrue(isIncludedColumn(eigenVector, ed.getV(), tolerance));
    }

    /**
     * Returns true iff there is a column that is a scalar multiple of column
     * in searchMatrix (modulo tolerance)
     */
    private boolean isIncludedColumn(double[] column, RealMatrix searchMatrix,
            double tolerance) {
        boolean found = false;
        int i = 0;
        while (!found && i < searchMatrix.getColumnDimension()) {
            double multiplier = 1.0;
            boolean matching = true;
            int j = 0;
            while (matching && j < searchMatrix.getRowDimension()) {
                double colEntry = searchMatrix.getEntry(j, i);
                // Use the first entry where both are non-zero as scalar
                if (FastMath.abs(multiplier - 1.0) <= FastMath.ulp(1.0) && FastMath.abs(colEntry) > 1E-14
                        && FastMath.abs(column[j]) > 1e-14) {
                    multiplier = colEntry / column[j];
                }
                if (FastMath.abs(column[j] * multiplier - colEntry) > tolerance) {
                    matching = false;
                }
                j++;
            }
            found = matching;
            i++;
        }
        return found;
    }

    @Before
    public void setUp() {
        refValues = new double[] {
                2.003, 2.002, 2.001, 1.001, 1.000, 0.001
        };
        matrix = createTestMatrix(new Random(35992629946426l), refValues);
    }

    @After
    public void tearDown() {
        refValues = null;
        matrix    = null;
    }

    static RealMatrix createTestMatrix(final Random r, final double[] eigenValues) {
        final int n = eigenValues.length;
        final RealMatrix v = createOrthogonalMatrix(r, n);
        final RealMatrix d = MatrixUtils.createRealDiagonalMatrix(eigenValues);
        return v.multiply(d).multiply(v.transpose());
    }

    public static RealMatrix createOrthogonalMatrix(final Random r, final int size) {

        final double[][] data = new double[size][size];

        for (int i = 0; i < size; ++i) {
            final double[] dataI = data[i];
            double norm2 = 0;
            do {

                // generate randomly row I
                for (int j = 0; j < size; ++j) {
                    dataI[j] = 2 * r.nextDouble() - 1;
                }

                // project the row in the subspace orthogonal to previous rows
                for (int k = 0; k < i; ++k) {
                    final double[] dataK = data[k];
                    double dotProduct = 0;
                    for (int j = 0; j < size; ++j) {
                        dotProduct += dataI[j] * dataK[j];
                    }
                    for (int j = 0; j < size; ++j) {
                        dataI[j] -= dotProduct * dataK[j];
                    }
                }

                // normalize the row
                norm2 = 0;
                for (final double dataIJ : dataI) {
                    norm2 += dataIJ * dataIJ;
                }
                final double inv = 1.0 / FastMath.sqrt(norm2);
                for (int j = 0; j < size; ++j) {
                    dataI[j] *= inv;
                }

            } while (norm2 * size < 0.01);
        }

        return MatrixUtils.createRealMatrix(data);

    }

	private static double[] INPUT1 = { 7484.860960227216, 18405.28129035345, 13855.225609560746, 10016.708722343366,
			559.8117399576674, 6750.190788301587, 71.21428769782159, -4175.088570476366, 1975.7955858241994,
			5193.178422374075, 1995.286659169179, 75.34535882933804, -234.0808002076056, 20654.744890306974412,
			16828.208208485466457, 6893.155912634994820, 6757.083016675340332, 5887.799885688558788, 64.309089923240379,
			57.992628792736340, -0.270356342026904, 0.852811091326997, 0.399639490702077, 0.198794657813990,
			0.019739323307666, 0.000106983022327, -0.000001216636321, 0.179995273578326, -0.402807848153042,
			0.701870993525734, 0.555058211014888, 0.068079148898236, 0.000509139115227, -0.000007112235617,
			-0.399582721284727, -0.056629954519333, -0.514406488522827, 0.711168164518580, 0.225548081276367,
			0.125943999652923, -0.004321507456014, 0.058515721572821, 0.010200130057739, 0.063516274916536,
			-0.090696087449378, -0.017148420432597, 0.991318870265707, -0.034707338554096, 0.855205995537564,
			0.327134656629775, -0.265382397060548, 0.282690729026706, 0.105736068025572, -0.009138126622039,
			0.000367751821196, -0.002913069901144, -0.005177515777101, 0.041906334478672, -0.109315918416258,
			0.436192305456741, 0.026307315639535, 0.891797507436344, -0.005738311176435, -0.010207611670378,
			0.082662420517928, -0.215733886094368, 0.861606487840411, -0.025478530652759, -0.451080697503958, 1.0e-3 };

	private static Object EXPECTED1 = null;

	private static double[] INPUT2 = { 1809.0978259647177, 3395.4763425956166, 1832.1894584712693, 3804.364873592377,
			806.0482458637571, 2403.656427234185, 28.48691431556015, -656.8932064545833, -469.30804108920734,
			-1021.7714889369421, -1152.540497328983, -939.9765163817368, -12.885877015422391, 4603.121913685183245,
			3691.195818048970978, 2743.442955402465032, 1657.596442107321764, 1336.797819095331306, 30.129865209677519,
			17.035352085224986, -0.036249830202337, 0.154184732411519, -0.346016328392363, 0.867540105133093,
			-0.294483395433451, 0.125854235969548, -0.000354507444044, -0.318654191697157, 0.912992309960507,
			-0.129270874079777, -0.184150038178035, 0.096521712579439, -0.070468788536461, 0.000247918177736,
			-0.051394668681147, 0.073102235876933, 0.173502042943743, -0.188311980310942, -0.327158794289386,
			0.905206581432676, -0.004296342252659, 0.838150199198361, 0.193305209055716, -0.457341242126146,
			-0.166933875895419, 0.094512811358535, 0.119062381338757, -0.000941755685226, 0.438071395458547,
			0.314969169786246, 0.768480630802146, 0.227919171600705, -0.193317045298647, -0.170305467485594,
			0.001677380536009, -0.003726503878741, -0.010091946369146, -0.067152015137611, -0.113798146542187,
			-0.313123000097908, -0.118940107954918, 0.932862311396062, 0.009373003194332, 0.025570377559400,
			0.170955836081348, 0.291954519805750, 0.807824267665706, 0.320108347088646, 0.360202112392266, 1.0e-4 };

	private static Object EXPECTED2 = null;

	@DataPoints public static Fixture[] DATA={new Fixture(INPUT1,EXPECTED1),new Fixture(INPUT2,EXPECTED2)};

	public static class Fixture {
		private double[] _input;
		private Object _expected;

		public Fixture(double[] _input, Object _expected) {
			this._input = _input;
			this._expected = _expected;
		}
	}
}