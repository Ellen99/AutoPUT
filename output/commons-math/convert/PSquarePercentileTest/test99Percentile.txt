/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math4.stat.descriptive.rank;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.Set;

import org.apache.commons.math4.distribution.LogNormalDistribution;
import org.apache.commons.math4.distribution.NormalDistribution;
import org.apache.commons.math4.distribution.RealDistribution;
import org.apache.commons.math4.distribution.AbstractRealDistribution;
import org.apache.commons.math4.exception.MathIllegalArgumentException;
import org.apache.commons.math4.exception.NullArgumentException;
import org.apache.commons.math4.exception.OutOfRangeException;
import org.apache.commons.rng.UniformRandomProvider;
import org.apache.commons.rng.simple.RandomSource;
import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatistic;
import org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest;
import org.apache.commons.math4.stat.descriptive.UnivariateStatistic;
import org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile;
import org.apache.commons.math4.stat.descriptive.rank.Percentile;
import org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.PSquareMarkers;
import org.apache.commons.math4.util.FastMath;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.experimental.theories.Theories;
import org.junit.experimental.theories.Theory;
import org.junit.experimental.theories.DataPoints;

/**
 * Test cases for the {@link PSquarePercentile} class which naturally extends
 * {@link StorelessUnivariateStatisticAbstractTest}.
 */
public @RunWith(Theories.class) class AutoPutTest extends
        StorelessUnivariateStatisticAbstractTest {

    @Override
    public double getTolerance() {
        return 1.0e-2;// tolerance limit changed as this is an approximation
        // algorithm and also gets accurate after few tens of
        // samples
    }

    @Override
    public UnivariateStatistic getUnivariateStatistic() {
        PSquarePercentile ptile = new PSquarePercentile(95);
        // Assert.assertNull(ptile.markers());
        return ptile;
    }

    @Override
    public double expectedValue() {
        return this.percentile95;
    }

    private Double[] randomTestData(int factor, int values) {
        Double[] test = new Double[values];
        for (int i = 0; i < test.length; i++) {
            test[i] = Math.abs(randomGenerator.nextDouble() * factor);
        }
        return test;
    }

    private void assertValues(Double a, Double b, double delta) {
        if (Double.isNaN(a)) {
            Assert.assertTrue("" + b + " is not NaN.", Double.isNaN(a));
        } else {
            double max = FastMath.max(a, b);
            double percentage = FastMath.abs(a - b) / max;
            double deviation = delta;
            Assert.assertTrue(String.format(
                    "Deviated = %f and is beyond %f as a=%f,  b=%f",
                    percentage, deviation, a, b), percentage < deviation);
        }
    }

    private void doCalculatePercentile(Double percentile, Number[] test) {
        doCalculatePercentile(percentile, test, Double.MAX_VALUE);
    }

    private void doCalculatePercentile(Double percentile, Number[] test,
            double delta) {
        PSquarePercentile psquared = new PSquarePercentile(percentile);
        for (Number value : test) {
            psquared.increment(value.doubleValue());
        }

        Percentile p2 = new Percentile(percentile * 100);

        double[] dall = new double[test.length];
        for (int i = 0; i < test.length; i++) {
            dall[i] = test[i].doubleValue();
        }

        Double referenceValue = p2.evaluate(dall);
        assertValues(psquared.getResult(), referenceValue, delta);
    }

    private void doCalculatePercentile(double percentile, double[] test,
            double delta) {
        PSquarePercentile psquared = new PSquarePercentile(percentile);
        for (double value : test) {
            psquared.increment(value);
        }

        Percentile p2 =
                new Percentile(percentile < 1 ? percentile * 100 : percentile);
        /*
         * double[] dall = new double[test.length]; for (int i = 0; i <
         * test.length; i++) dall[i] = test[i];
         */
        Double referenceValue = p2.evaluate(test);
        assertValues(psquared.getResult(), referenceValue, delta);
    }

    @Theory
	public void autoPutTest(Fixture fixture) {
        Double[] test = randomTestData(fixture._input[0], fixture._input[1]);
        doCalculatePercentile(fixture._input[2], test);
    }

    private void doDistributionTest(RealDistribution distribution) {
        final RealDistribution.Sampler sampler =
            distribution.createSampler(RandomSource.create(RandomSource.WELL_19937_C, 1000));
        double data[];

        data = AbstractRealDistribution.sample(VERY_LARGE, sampler);
        doCalculatePercentile(50, data, 0.0001);
        doCalculatePercentile(95, data, 0.0001);

        data = AbstractRealDistribution.sample(LARGE, sampler);
        doCalculatePercentile(50, data, 0.001);
        doCalculatePercentile(95, data, 0.001);

        data = AbstractRealDistribution.sample(VERY_BIG, sampler);
        doCalculatePercentile(50, data, 0.001);
        doCalculatePercentile(95, data, 0.001);

        data = AbstractRealDistribution.sample(BIG, sampler);
        doCalculatePercentile(50, data, 0.001);
        doCalculatePercentile(95, data, 0.001);

        data = AbstractRealDistribution.sample(STANDARD, sampler);
        doCalculatePercentile(50, data, 0.005);
        doCalculatePercentile(95, data, 0.005);

        data = AbstractRealDistribution.sample(MEDIUM, sampler);
        doCalculatePercentile(50, data, 0.005);
        doCalculatePercentile(95, data, 0.005);

        data = AbstractRealDistribution.sample(NOMINAL, sampler);
        doCalculatePercentile(50, data, 0.01);
        doCalculatePercentile(95, data, 0.01);

        data = AbstractRealDistribution.sample(SMALL, sampler);
        doCalculatePercentile(50, data, 0.01);
        doCalculatePercentile(95, data, 0.01);

        data = AbstractRealDistribution.sample(TINY, sampler);
        doCalculatePercentile(50, data, 0.05);
        doCalculatePercentile(95, data, 0.05);

    }

    private static double[] INPUT1 = { 100, 10000, 0.99d };

	private static double[] EXPECTED1 = null;

	private static double[] INPUT2 = { 100, 10000, 0.90d };

	private static double[] EXPECTED2 = null;

	private static double[] INPUT3 = { 100, 100000, 0.20d };

	private static double[] EXPECTED3 = null;

	private static double[] INPUT4 = { 50, 990000, 0.50d };

	private static double[] EXPECTED4 = null;

	private static double[] INPUT5 = { 100000, 10000, 0.99d };

	private static double[] EXPECTED5 = null;

	private static double[] INPUT6 = { 100000, 100000, 0.90d };

	private static double[] EXPECTED6 = null;

	private static double[] INPUT7 = { 100000, 100000, 0.20d };

	private static double[] EXPECTED7 = null;

	private static double[] INPUT8 = { 100000, 100000, 0.05d };

	private static double[] EXPECTED8 = null;

	@DataPoints public static Fixture[] DATA={new Fixture(INPUT1,EXPECTED1),new Fixture(INPUT2,EXPECTED2),new Fixture(INPUT3,EXPECTED3),new Fixture(INPUT4,EXPECTED4),new Fixture(INPUT5,EXPECTED5),new Fixture(INPUT6,EXPECTED6),new Fixture(INPUT7,EXPECTED7),new Fixture(INPUT8,EXPECTED8)};

	public static class Fixture {
		private double[] _input;
		private Object _expected;

		public Fixture(double[] _input, Object _expected) {
			this._input = _input;
			this._expected = _expected;
		}
	}
}