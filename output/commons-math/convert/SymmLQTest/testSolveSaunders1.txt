/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math4.linear;

import java.util.Arrays;

import org.apache.commons.math4.exception.DimensionMismatchException;
import org.apache.commons.math4.linear.Array2DRowRealMatrix;
import org.apache.commons.math4.linear.ArrayRealVector;
import org.apache.commons.math4.linear.DecompositionSolver;
import org.apache.commons.math4.linear.IterativeLinearSolver;
import org.apache.commons.math4.linear.IterativeLinearSolverEvent;
import org.apache.commons.math4.linear.JacobiPreconditioner;
import org.apache.commons.math4.linear.LUDecomposition;
import org.apache.commons.math4.linear.NonPositiveDefiniteOperatorException;
import org.apache.commons.math4.linear.NonSelfAdjointOperatorException;
import org.apache.commons.math4.linear.NonSquareOperatorException;
import org.apache.commons.math4.linear.PreconditionedIterativeLinearSolver;
import org.apache.commons.math4.linear.RealLinearOperator;
import org.apache.commons.math4.linear.RealVector;
import org.apache.commons.math4.linear.SymmLQ;
import org.apache.commons.math4.util.FastMath;
import org.apache.commons.math4.util.IterationEvent;
import org.apache.commons.math4.util.IterationListener;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.experimental.theories.Theories;
import org.junit.experimental.theories.Theory;
import org.junit.experimental.theories.DataPoints;

public @RunWith(Theories.class) class AutoPutTest {

    public void saundersTest(final int n, final boolean goodb,
                             final boolean precon, final double shift,
                             final double pertbn) {
        final RealLinearOperator a = new RealLinearOperator() {

            @Override
            public RealVector operate(final RealVector x) {
                if (x.getDimension() != n) {
                    throw new DimensionMismatchException(x.getDimension(), n);
                }
                final double[] y = new double[n];
                for (int i = 0; i < n; i++) {
                    y[i] = (i + 1) * 1.1 / n * x.getEntry(i);
                }
                return new ArrayRealVector(y, false);
            }

            @Override
            public int getRowDimension() {
                return n;
            }

            @Override
            public int getColumnDimension() {
                return n;
            }
        };
        final double shiftm = shift;
        final double pertm = FastMath.abs(pertbn);
        final RealLinearOperator minv;
        if (precon) {
            minv = new RealLinearOperator() {
                @Override
                public int getRowDimension() {
                    return n;
                }

                @Override
                public int getColumnDimension() {
                    return n;
                }

                @Override
                public RealVector operate(final RealVector x) {
                    if (x.getDimension() != n) {
                        throw new DimensionMismatchException(x.getDimension(),
                                                             n);
                    }
                    final double[] y = new double[n];
                    for (int i = 0; i < n; i++) {
                        double d = (i + 1) * 1.1 / n;
                        d = FastMath.abs(d - shiftm);
                        if (i % 10 == 0) {
                            d += pertm;
                        }
                        y[i] = x.getEntry(i) / d;
                    }
                    return new ArrayRealVector(y, false);
                }
            };
        } else {
            minv = null;
        }
        final RealVector xtrue = new ArrayRealVector(n);
        for (int i = 0; i < n; i++) {
            xtrue.setEntry(i, n - i);
        }
        final RealVector b = a.operate(xtrue);
        b.combineToSelf(1.0, -shift, xtrue);
        final SymmLQ solver = new SymmLQ(2 * n, 1E-12, true);
        final RealVector x = solver.solve(a, minv, b, goodb, shift);
        final RealVector y = a.operate(x);
        final RealVector r1 = new ArrayRealVector(n);
        for (int i = 0; i < n; i++) {
            final double bi = b.getEntry(i);
            final double yi = y.getEntry(i);
            final double xi = x.getEntry(i);
            r1.setEntry(i, bi - yi + shift * xi);
        }
        final double enorm = x.subtract(xtrue).getNorm() / xtrue.getNorm();
        final double etol = 1E-5;
        Assert.assertTrue("enorm=" + enorm + ", " +
        solver.getIterationManager().getIterations(), enorm <= etol);
    }

    @Theory
	public void autoPutTest(Fixture fixture) {
        saundersTest(new Integer(fixture._input[0].toString()), new Boolean(fixture._input[1].toString()), new Boolean(fixture._input[2].toString()), new Double(fixture._input[3].toString()), new Double(fixture._input[4].toString()));
    }

    private static Object[] INPUT1 = { 1, false, false, 0., 0. };

	private static Object EXPECTED1 = null;

	private static Object[] INPUT2 = { 2, false, false, 0., 0. };

	private static Object EXPECTED2 = null;

	private static Object[] INPUT3 = { 1, false, true, 0., 0. };

	private static Object EXPECTED3 = null;

	private static Object[] INPUT4 = { 2, false, true, 0., 0. };

	private static Object EXPECTED4 = null;

	private static Object[] INPUT5 = { 5, false, true, 0., 0. };

	private static Object EXPECTED5 = null;

	private static Object[] INPUT6 = { 5, false, true, 0.25, 0. };

	private static Object EXPECTED6 = null;

	private static Object[] INPUT7 = { 50, false, false, 0., 0. };

	private static Object EXPECTED7 = null;

	private static Object[] INPUT8 = { 50, false, false, 0.25, 0. };

	private static Object EXPECTED8 = null;

	private static Object[] INPUT9 = { 50, false, true, 0., 0.10 };

	private static Object EXPECTED9 = null;

	private static Object[] INPUT10 = { 50, false, true, 0.25, 0.10 };

	private static Object EXPECTED10 = null;

	private static Object[] INPUT11 = { 1, true, false, 0., 0. };

	private static Object EXPECTED11 = null;

	private static Object[] INPUT12 = { 2, true, false, 0., 0. };

	private static Object EXPECTED12 = null;

	private static Object[] INPUT13 = { 1, true, true, 0., 0. };

	private static Object EXPECTED13 = null;

	private static Object[] INPUT14 = { 2, true, true, 0., 0. };

	private static Object EXPECTED14 = null;

	private static Object[] INPUT15 = { 5, true, true, 0., 0. };

	private static Object EXPECTED15 = null;

	private static Object[] INPUT16 = { 5, true, true, 0.25, 0. };

	private static Object EXPECTED16 = null;

	private static Object[] INPUT17 = { 50, true, false, 0., 0. };

	private static Object EXPECTED17 = null;

	private static Object[] INPUT18 = { 50, true, false, 0.25, 0. };

	private static Object EXPECTED18 = null;

	private static Object[] INPUT19 = { 50, true, true, 0., 0.10 };

	private static Object EXPECTED19 = null;

	private static Object[] INPUT20 = { 50, true, true, 0.25, 0.10 };

	private static Object EXPECTED20 = null;

	@DataPoints public static Fixture[] DATA={new Fixture(INPUT1,EXPECTED1),new Fixture(INPUT2,EXPECTED2),new Fixture(INPUT3,EXPECTED3),new Fixture(INPUT4,EXPECTED4),new Fixture(INPUT5,EXPECTED5),new Fixture(INPUT6,EXPECTED6),new Fixture(INPUT7,EXPECTED7),new Fixture(INPUT8,EXPECTED8),new Fixture(INPUT9,EXPECTED9),new Fixture(INPUT10,EXPECTED10),new Fixture(INPUT11,EXPECTED11),new Fixture(INPUT12,EXPECTED12),new Fixture(INPUT13,EXPECTED13),new Fixture(INPUT14,EXPECTED14),new Fixture(INPUT15,EXPECTED15),new Fixture(INPUT16,EXPECTED16),new Fixture(INPUT17,EXPECTED17),new Fixture(INPUT18,EXPECTED18),new Fixture(INPUT19,EXPECTED19),new Fixture(INPUT20,EXPECTED20)};

	public static class Fixture {
		private Object[] _input;
		private Object _expected;

		public Fixture(Object[] _input, Object _expected) {
			this._input = _input;
			this._expected = _expected;
		}
	}
}
