/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.math4.geometry.euclidean.threed;

import org.apache.commons.numbers.angle.PlaneAngleRadians;
import org.apache.commons.math4.dfp.Dfp;
import org.apache.commons.math4.dfp.DfpField;
import org.apache.commons.math4.exception.MathArithmeticException;
import org.apache.commons.math4.exception.MathIllegalArgumentException;
import org.apache.commons.math4.geometry.euclidean.threed.CardanEulerSingularityException;
import org.apache.commons.math4.geometry.euclidean.threed.FieldRotation;
import org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D;
import org.apache.commons.math4.geometry.euclidean.threed.NotARotationMatrixException;
import org.apache.commons.math4.geometry.euclidean.threed.Rotation;
import org.apache.commons.math4.geometry.euclidean.threed.RotationOrder;
import org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D;
import org.apache.commons.math4.random.UnitSphereRandomVectorGenerator;
import org.apache.commons.rng.UniformRandomProvider;
import org.apache.commons.rng.simple.RandomSource;
import org.apache.commons.math4.util.FastMath;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameters;


public @RunWith(Parameterized.class) class FieldRotationDfpTest {

    @Test
    public void testRevertVectorOperator() {
        double a = 0.001;
        double b = 0.36;
        double c = 0.48;
        double d = 0.8;
        FieldRotation<Dfp> r = createRotation(a, b, c, d, true);
        FieldRotation<Dfp> reverted = r.revert();
        FieldRotation<Dfp> rrT = r.compose(reverted, _input[0]);
        checkRotationDS(rrT, 1, 0, 0, 0);
        FieldRotation<Dfp> rTr = reverted.compose(r, _input[1]);
        checkRotationDS(rTr, 1, 0, 0, 0);
        Assert.assertEquals(r.getAngle().getReal(), reverted.getAngle().getReal(), 1.0e-15);
        Assert.assertEquals(-1,
                            FieldVector3D.dotProduct(r.getAxis(_input[2]),
                                                     reverted.getAxis(_input[3])).getReal(),
                            1.0e-15);
    }

    private void checkAngle(Dfp a1, double a2) {
        Assert.assertEquals(a1.getReal(), PlaneAngleRadians.normalize(a2, a1.getReal()), 1.0e-10);
    }

    private void checkRotationDS(FieldRotation<Dfp> r, double q0, double q1, double q2, double q3) {
        FieldRotation<Dfp> rPrime = createRotation(q0, q1, q2, q3, false);
        Assert.assertEquals(0, FieldRotation.distance(r, rPrime).getReal(), 1.0e-12);
    }

    private FieldRotation<Dfp> createRotation(double q0, double q1, double q2, double q3,
                                      boolean needsNormalization) {
        DfpField field = new DfpField(20);
        return new FieldRotation<>(field.newDfp(q0),
                                      field.newDfp(q1),
                                      field.newDfp(q2),
                                      field.newDfp(q3),
                                      needsNormalization);
    }

    private FieldRotation<Dfp> createRotation(double[][] m, double threshold) {
        DfpField field = new DfpField(20);
        Dfp[][] mds = new Dfp[m.length][m[0].length];
        for (int i = 0; i < m.length; ++i) {
            for (int j = 0; j < m[i].length; ++j) {
                mds[i][j] = field.newDfp(m[i][j]);
            }
        }
        return new FieldRotation<>(mds, threshold);
    }

    private FieldVector3D<Dfp> createVector(double x, double y, double z) {
        DfpField field = new DfpField(20);
        return new FieldVector3D<>(field.newDfp(x), field.newDfp(y), field.newDfp(z));
    }

    private FieldVector3D<Dfp> createAxis(double x, double y, double z) {
        DfpField field = new DfpField(20);
        return new FieldVector3D<>(field.newDfp(x), field.newDfp(y), field.newDfp(z));
    }

    private Dfp createAngle(double alpha) {
        return new DfpField(20).newDfp(alpha);
    }

    private void checkVector(FieldVector3D<Dfp> u, FieldVector3D<Dfp> v) {
        Assert.assertEquals(u.getX().getReal(), v.getX().getReal(), 1.0e-12);
        Assert.assertEquals(u.getY().getReal(), v.getY().getReal(), 1.0e-12);
        Assert.assertEquals(u.getZ().getReal(), v.getZ().getReal(), 1.0e-12);
    }

	@Parameters public static Collection<Object[]> data(){return Arrays.asList(new Object[][]{{{RotationConvention.VECTOR_OPERATOR,RotationConvention.VECTOR_OPERATOR,RotationConvention.VECTOR_OPERATOR,RotationConvention.VECTOR_OPERATOR},{}},{{RotationConvention.FRAME_TRANSFORM,RotationConvention.FRAME_TRANSFORM,RotationConvention.FRAME_TRANSFORM,RotationConvention.FRAME_TRANSFORM},{}}});}

	private Object[] _input;
	private Object _expected;

	public AutoPUT(Object[] _input, Object _expected) {
		this._input = _input;
		this._expected = _expected;
	}

}