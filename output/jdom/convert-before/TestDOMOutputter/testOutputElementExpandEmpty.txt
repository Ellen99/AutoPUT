package org.jdom2.test.cases.output;

/* Please run replic.pl on me ! */
/**
 * Please put a description of your test here.
 * 
 * @author unascribed
 * @version 0.1
 */

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.List;

import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.w3c.dom.Attr;

import org.jdom2.Attribute;
import org.jdom2.CDATA;
import org.jdom2.Comment;
import org.jdom2.Content;
import org.jdom2.DocType;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.EntityRef;
import org.jdom2.JDOMException;
import org.jdom2.Namespace;
import org.jdom2.ProcessingInstruction;
import org.jdom2.Text;
import org.jdom2.adapters.DOMAdapter;
import org.jdom2.adapters.JAXPDOMAdapter;
import org.jdom2.input.DOMBuilder;
import org.jdom2.output.DOMOutputter;
import org.jdom2.output.Format;
import org.jdom2.output.LineSeparator;
import org.jdom2.output.XMLOutputter;
import org.jdom2.output.support.AbstractDOMOutputProcessor;
import org.jdom2.output.support.DOMOutputProcessor;
import org.jdom2.test.util.UnitTestUtil;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameters;

@SuppressWarnings("javadoc")
public final @RunWith(Parameterized.class) class TestDOMOutputter extends AbstractTestOutputter {

    /**
     * The main method runs all the tests in the text ui
     */
    public static void main (String args[]) 
     {
        JUnitCore.runClasses(TestDOMOutputter.class);
    }
    
    private interface DOMSetup {
    	public DOMOutputter buildOutputter();
    }
    
    private void roundTrip(Document doc) {
    	roundTrip(null, doc);
    }
    
    private void roundTrip(DOMSetup setup, Document doc) {
    	XMLOutputter xout = new XMLOutputter(Format.getRawFormat());
    	// create a String representation of the input.
    	if (doc.hasRootElement()) {
    		UnitTestUtil.normalizeAttributes(doc.getRootElement());
    	}
    	String expect = xout.outputString(doc);
    	
    	String actual = null;
    	try {
    		// convert the input to a DOM document
        	DOMOutputter domout = setup == null ? new DOMOutputter() : setup.buildOutputter();
			org.w3c.dom.Document outonce = domout.output(doc);
			
			// convert the DOM document back again.
			DOMBuilder builder = new DOMBuilder();
			Document backagain = builder.build(outonce);
			
			// get a String representation of the round-trip.
	    	if (backagain.hasRootElement()) {
	    		UnitTestUtil.normalizeAttributes(backagain.getRootElement());
	    	}
			actual = xout.outputString(backagain);
		} catch (JDOMException e) {
			e.printStackTrace();
			fail("Failed to round-trip the document with exception: " 
					+ e.getMessage() + "\n" + expect);
		}
    	assertEquals(expect, actual);
    }
    
    private final DOMOutputter getOutputter(Format format) {
    	DOMOutputter outputter = new DOMOutputter();
    	outputter.setFormat(format);
    	return outputter;
    }
    
	private final String nodeToString (Object input) {
    	try {
    		// Do not use Transforms, messes up end-of-lines, etc.
    		// instead, reuse the DOMBuilder and convert back to string using
    		// XMLOutputter.
    		if (input == null) {
    			return "";
    		}
    		XMLOutputter xout = new XMLOutputter();
    		xout.getFormat().setLineSeparator(LineSeparator.NL);
    		DOMBuilder builder = new DOMBuilder();
    		
    		if (input instanceof List) {
    			StringBuilder sb = new StringBuilder();
    			for (Object o : (List<?>)input) {
    				sb.append(nodeToString(o));
    			}
    			return sb.toString();
    		}
    		if (input instanceof org.w3c.dom.Document) {
    			return xout.outputString(builder.build((org.w3c.dom.Document)input));
    		}
    		if (input instanceof org.w3c.dom.CDATASection) {
				return xout.outputString(builder.build((org.w3c.dom.CDATASection)input));
    		}
    		if (input instanceof org.w3c.dom.Comment) {
				return xout.outputString(builder.build((org.w3c.dom.Comment)input));
    		}
    		if (input instanceof org.w3c.dom.DocumentType) {
				return xout.outputString(builder.build((org.w3c.dom.DocumentType)input));
    		}
    		if (input instanceof org.w3c.dom.Element) {
				return xout.outputString(builder.build((org.w3c.dom.Element)input));
    		}
    		if (input instanceof org.w3c.dom.EntityReference) {
				return xout.outputString(builder.build((org.w3c.dom.EntityReference)input));
    		}
    		if (input instanceof org.w3c.dom.ProcessingInstruction) {
				return xout.outputString(builder.build((org.w3c.dom.ProcessingInstruction)input));
    		}
    		if (input instanceof org.w3c.dom.Text) {
				return xout.outputString(builder.build((org.w3c.dom.Text)input));
    		}

    		return null;
//	    	TransformerFactory factory = TransformerFactory.newInstance();
//	    	Transformer transformer = factory.newTransformer();
//	    	transformer.setOutputProperty("{http://xml.apache.org/xalan}line-separator","\n");	    	
//	    	StringWriter writer = new StringWriter();
//	    	for (Node node : nodes) {
//	    		if (node instanceof org.w3c.dom.Document) {
//	    			((org.w3c.dom.Document)node).setXmlStandalone(true);
//	    			transformer.setOutputProperty("omit-xml-declaration", "no");
//	    		} else {
//	    			transformer.setOutputProperty("omit-xml-declaration", "yes");
//	    		}
//		    	Result result = new StreamResult(writer);
//		    	Source source = new DOMSource(node);
//		    	transformer.transform(source, result);
//	    	}
//	    	writer.close();
//	    	String xml = writer.toString();
//	    	return xml;
    	} catch (Exception e) {
    		throw new IllegalStateException(e);
    	}
    }
    
	@Override
	public String outputDocumentAsString(Format format, Document doc) {
		try {
			DOMOutputter out = getOutputter(format);
			String opta = nodeToString(out.output(doc));
			return opta;
		} catch (JDOMException e) {
			UnitTestUtil.failException("Unexpected JDOMException", e);
			return null;
		}
	}

	@Override
	public String outputDocTypeAsString(Format format, DocType doctype) {
		try {
			DOMOutputter out = getOutputter(format);
//			org.w3c.dom.Document doc = out.getDOMAdapter().createDocument();
			String opta = nodeToString(out.output(doctype));
//			String optb = nodeToString(out.output(doc, doctype));
//			assertEquals(opta, optb);
			return opta;
		} catch (JDOMException e) {
			UnitTestUtil.failException("Unexpected JDOMException", e);
			return null;
		}
	}

	@Override
	public String outputElementAsString(Format format, Element element) {
		try {
			DOMOutputter out = getOutputter(format);
			org.w3c.dom.Document doc = out.getDOMAdapter().createDocument();
			String opta = nodeToString(out.output(element));
			String optb = nodeToString(out.output(doc, element));
			assertEquals(opta, optb);
			return opta;
		} catch (JDOMException e) {
			UnitTestUtil.failException("Unexpected JDOMException", e);
			return null;
		}
	}

	@Override
	public String outputListAsString(Format format, List<? extends Content> list) {
		try {
			DOMOutputter out = getOutputter(format);
			org.w3c.dom.Document doc = out.getDOMAdapter().createDocument();
			String opta = nodeToString(out.output(list));
			String optb = nodeToString(out.output(doc, list));
			assertEquals(opta, optb);
			return opta;
		} catch (JDOMException e) {
			UnitTestUtil.failException("Unexpected JDOMException", e);
			return null;
		}
	}

	@Override
	public String outputCDataAsString(Format format, CDATA cdata) {
		try {
			DOMOutputter out = getOutputter(format);
			org.w3c.dom.Document doc = out.getDOMAdapter().createDocument();
			String opta = nodeToString(out.output(cdata));
			String optb = nodeToString(out.output(doc, cdata));
			assertEquals(opta, optb);
			return opta;
		} catch (JDOMException e) {
			UnitTestUtil.failException("Unexpected JDOMException", e);
			return null;
		}
	}

	@Override
	public String outputTextAsString(Format format, Text text) {
		try {
			DOMOutputter out = getOutputter(format);
			org.w3c.dom.Document doc = out.getDOMAdapter().createDocument();
			String opta = nodeToString(out.output(text));
			String optb = nodeToString(out.output(doc, text));
			assertEquals(opta, optb);
			return opta;
		} catch (JDOMException e) {
			UnitTestUtil.failException("Unexpected JDOMException", e);
			return null;
		}
	}

	@Override
	public String outputCommentAsString(Format format, Comment comment) {
		try {
			DOMOutputter out = getOutputter(format);
			org.w3c.dom.Document doc = out.getDOMAdapter().createDocument();
			String opta = nodeToString(out.output(comment));
			String optb = nodeToString(out.output(doc, comment));
			assertEquals(opta, optb);
			return opta;
		} catch (JDOMException e) {
			UnitTestUtil.failException("Unexpected JDOMException", e);
			return null;
		}
	}

	@Override
	public String outputPIAsString(Format format, ProcessingInstruction pi) {
		try {
			DOMOutputter out = getOutputter(format);
			org.w3c.dom.Document doc = out.getDOMAdapter().createDocument();
			String opta = nodeToString(out.output(pi));
			String optb = nodeToString(out.output(doc, pi));
			assertEquals(opta, optb);
			return opta;
		} catch (JDOMException e) {
			UnitTestUtil.failException("Unexpected JDOMException", e);
			return null;
		}
	}

	@Override
	public String outputEntityRefAsString(Format format, EntityRef entity) {
		try {
			DOMOutputter out = getOutputter(format);
			org.w3c.dom.Document doc = out.getDOMAdapter().createDocument();
			String opta = nodeToString(out.output(entity));
			String optb = nodeToString(out.output(doc, entity));
			assertEquals(opta, optb);
			return opta;
		} catch (JDOMException e) {
			UnitTestUtil.failException("Unexpected JDOMException", e);
			return null;
		}
	}

	@Override
	public String outputElementContentString(Format format, Element element) {
		try {
			DOMOutputter out = getOutputter(format);
			org.w3c.dom.Document doc = out.getDOMAdapter().createDocument();
			String opta = nodeToString(out.output(element.getContent()));
			String optb = nodeToString(out.output(doc, element.getContent()));
			assertEquals(opta, optb);
			return opta;
		} catch (JDOMException e) {
			UnitTestUtil.failException("Unexpected JDOMException", e);
			return null;
		}
	}
    
    @Override
    @Ignore // we can't control expand in DOM.
    public void testOutputElementExpandEmpty() {
    	// pass this test always.
    }

    @Parameters public static Collection<Object[]> data(){return Arrays.asList(new Object[][]{{{},{}},{{},{}},{{},{}},{{},{}}});}

	private Object _input;
	private Object _expected;

	public AutoPUT(Object _input, Object _expected) {
		this._input = _input;
		this._expected = _expected;
	}
    
}