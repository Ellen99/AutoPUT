package org.jdom2.test.cases.output;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import org.junit.Ignore;
import org.junit.Test;
import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.DTDHandler;
import org.xml.sax.EntityResolver;
import org.xml.sax.ErrorHandler;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.SAXParseException;
import org.xml.sax.ext.DeclHandler;
import org.xml.sax.ext.DefaultHandler2;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.helpers.AttributesImpl;
import org.xml.sax.helpers.LocatorImpl;

import org.jdom2.Attribute;
import org.jdom2.AttributeType;
import org.jdom2.CDATA;
import org.jdom2.Comment;
import org.jdom2.Content;
import org.jdom2.DocType;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.EntityRef;
import org.jdom2.JDOMException;
import org.jdom2.Namespace;
import org.jdom2.ProcessingInstruction;
import org.jdom2.Text;
import org.jdom2.input.sax.SAXHandler;
import org.jdom2.output.Format;
import org.jdom2.output.JDOMLocator;
import org.jdom2.output.LineSeparator;
import org.jdom2.output.SAXOutputter;
import org.jdom2.output.XMLOutputter;
import org.jdom2.output.support.AbstractSAXOutputProcessor;
import org.jdom2.output.support.SAXOutputProcessor;
import org.jdom2.test.util.UnitTestUtil;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameters;


@SuppressWarnings("javadoc")
public @RunWith(Parameterized.class) class TestSAXOutputter extends AbstractTestOutputter {
	
    private interface SAXSetup {
    	public SAXOutputter buildOutputter(SAXHandler handler);
    }
    
    

    private void roundTrip(Document doc) {
    	roundTrip(null, doc);
    }
    
    private void roundTrip(SAXSetup setup, Document doc) {
    	XMLOutputter xout = new XMLOutputter(Format.getRawFormat());
    	// create a String representation of the input.
    	if (doc.hasRootElement()) {
    		UnitTestUtil.normalizeAttributes(doc.getRootElement());
    	}
    	String expect = xout.outputString(doc);
    	
    	String actual = null;
    	try {
    		// convert the input to a SAX Stream
    		SAXHandler handler = new SAXHandler();
        	SAXOutputter saxout = setup == null 
        			? new SAXOutputter(handler, handler, handler, handler, handler) 
        			: setup.buildOutputter(handler);

        	saxout.output(doc);
        	
			Document backagain = handler.getDocument();
			
			// get a String representation of the round-trip.
	    	if (backagain.hasRootElement()) {
	    		UnitTestUtil.normalizeAttributes(backagain.getRootElement());
	    	}
			actual = xout.outputString(backagain);
		} catch (JDOMException e) {
			e.printStackTrace();
			fail("Failed to round-trip the document with exception: " 
					+ e.getMessage() + "\n" + expect);
		}
    	assertEquals(expect, actual);
    }
    
    private void roundTrip(SAXSetup setup, Element emt) {
    	XMLOutputter xout = new XMLOutputter(Format.getRawFormat());
    	Document tstdoc = new Document();
    	tstdoc.addContent(emt.clone());
    	String expect = xout.outputString(tstdoc);
    	
    	String actual = null;
    	try {
    		// convert the input to a SAX Stream
    		SAXHandler handler = new SAXHandler();
        	SAXOutputter saxout = setup == null 
        			? new SAXOutputter(handler, handler, handler, handler, handler) 
        			: setup.buildOutputter(handler);

        	saxout.output(emt);
        	
			Document backagain = handler.getDocument();
			
			// get a String representation of the round-trip.
	    	if (backagain.hasRootElement()) {
	    		UnitTestUtil.normalizeAttributes(backagain.getRootElement());
	    	}
			actual = xout.outputString(backagain);
		} catch (JDOMException e) {
			e.printStackTrace();
			fail("Failed to round-trip the document with exception: " 
					+ e.getMessage() + "\n" + expect);
		}
    	assertEquals(expect, actual);
    }
    
    private void roundTripFragment(SAXSetup setup, List<Content> content) {
    	XMLOutputter xout = new XMLOutputter(Format.getRawFormat());
    	Element root = new Element("root");
    	Document tstdoc = new Document(root);
    	
    	for (Content c : content) {
    		root.addContent(c);
    	}
    	
    	String expect = xout.outputString(tstdoc);
    	
    	String actual = null;
    	try {
    		// convert the input to a SAX Stream
    		SAXHandler handler = new SAXHandler();
        	SAXOutputter saxout = setup == null 
        			? new SAXOutputter(handler, handler, handler, handler, handler) 
        			: setup.buildOutputter(handler);

        	Locator loc = new LocatorImpl();
        	handler.setDocumentLocator(loc);
        	handler.startDocument();
        	handler.startElement("", "root", "root", new AttributesImpl());
        	saxout.outputFragment(content);
        	handler.endElement("", "root", "root");
        	handler.endDocument();
        	
			Document backagain = handler.getDocument();
			
			// get a String representation of the round-trip.
	    	if (backagain.hasRootElement()) {
	    		UnitTestUtil.normalizeAttributes(backagain.getRootElement());
	    	}
			actual = xout.outputString(backagain);
		} catch (Exception e) {
			e.printStackTrace();
			fail("Failed to round-trip the document with exception: " 
					+ e.getMessage() + "\n" + expect);
		}
    	assertEquals(expect, actual);
    }
    
    private void roundTripFragment(SAXSetup setup, Content content) {
    	XMLOutputter xout = new XMLOutputter(Format.getRawFormat());
    	Element root = new Element("root");
    	Document tstdoc = new Document(root);
    	
   		root.addContent(content);
    	
    	String expect = xout.outputString(tstdoc);
    	
    	String actual = null;
    	try {
    		// convert the input to a SAX Stream
    		SAXHandler handler = new SAXHandler();
        	SAXOutputter saxout = setup == null 
        			? new SAXOutputter(handler, handler, handler, handler, handler) 
        			: setup.buildOutputter(handler);

        	Locator loc = new LocatorImpl();
        	handler.setDocumentLocator(loc);
        	handler.startDocument();
        	handler.startElement("", "root", "root", new AttributesImpl());
        	saxout.outputFragment(content);
        	handler.endElement("", "root", "root");
        	handler.endDocument();
        	
			Document backagain = handler.getDocument();
			
			// get a String representation of the round-trip.
	    	if (backagain.hasRootElement()) {
	    		UnitTestUtil.normalizeAttributes(backagain.getRootElement());
	    	}
			actual = xout.outputString(backagain);
		} catch (Exception e) {
			e.printStackTrace();
			fail("Failed to round-trip the document with exception: " 
					+ e.getMessage() + "\n" + expect);
		}
    	assertEquals(expect, actual);
    }
    
    private void roundTrip(SAXSetup setup, List<? extends Content> content) {
    	XMLOutputter xout = new XMLOutputter(Format.getRawFormat());
    	Document tstdoc = new Document();
    	for (Object o : content) {
    		tstdoc.addContent((Content)o);
    	}
    	String expect = xout.outputString(tstdoc);
    	
    	String actual = null;
    	try {
    		// convert the input to a SAX Stream
    		SAXHandler handler = new SAXHandler();
        	SAXOutputter saxout = setup == null 
        			? new SAXOutputter(handler, handler, handler, handler, handler) 
        			: setup.buildOutputter(handler);

        	saxout.output(content);
        	
			Document backagain = handler.getDocument();
			
			// get a String representation of the round-trip.
	    	if (backagain.hasRootElement()) {
	    		UnitTestUtil.normalizeAttributes(backagain.getRootElement());
	    	}
			actual = xout.outputString(backagain);
		} catch (JDOMException e) {
			e.printStackTrace();
			fail("Failed to round-trip the document with exception: " 
					+ e.getMessage() + "\n" + expect);
		}
    	assertEquals(expect, actual);
    }
    

	@Override
	public String outputDocumentAsString(Format format, Document doc) {
		SAXHandler handler = new SAXHandler();
		SAXOutputter saxout = new SAXOutputter(null, format, handler, handler, 
				handler, handler, handler);
		try {
			saxout.output(doc);
		} catch (Exception e) {
			throw new IllegalStateException("Could not output", e);
		}
		XMLOutputter xout = new XMLOutputter();
		xout.getFormat().setLineSeparator(LineSeparator.NL);
		return xout.outputString(handler.getDocument());
	}

	@Override
	public String outputDocTypeAsString(Format format, DocType doctype) {
		SAXHandler handler = new SAXHandler();
		SAXOutputter saxout = new SAXOutputter(null, format, handler, handler, 
				handler, handler, handler);
		List<Content> list = new ArrayList<Content>(1);
		list.add(doctype);
		//list.add(new Element("root"));
		
		try {
			saxout.output(list);
		} catch (Exception e) {
			throw new IllegalStateException("Could not output", e);
		}
		XMLOutputter xout = new XMLOutputter();
		xout.getFormat().setLineSeparator(LineSeparator.NL);
		return xout.outputString(handler.getDocument().getDocType());
	}

	@Override
	public String outputElementAsString(Format format, Element element) {
		SAXHandler handler = new SAXHandler();
		SAXOutputter saxout = new SAXOutputter(null, format, handler, handler, 
				handler, handler, handler);
		
		try {
			saxout.output(element);
		} catch (Exception e) {
			throw new IllegalStateException("Could not output", e);
		}
		XMLOutputter xout = new XMLOutputter();
		xout.getFormat().setLineSeparator(LineSeparator.NL);
		return xout.outputString(handler.getDocument().getRootElement());
	}

	@Override
	public String outputListAsString(Format format, List<? extends Content> list) {
		SAXHandler handler = new SAXHandler();
		SAXOutputter saxout = new SAXOutputter(null, format, handler, handler, 
				handler, handler, handler);
		
		try {
			handler.startDocument();
			handler.startElement("", "root", "root", new AttributesImpl());
			saxout.outputFragment(list);
			handler.endElement("", "root", "root");
			handler.endDocument();
		} catch (Exception e) {
			throw new IllegalStateException("Could not output", e);
		}
		XMLOutputter xout = new XMLOutputter();
		xout.getFormat().setLineSeparator(LineSeparator.NL);
		return xout.outputString(handler.getDocument().getRootElement().getContent());
	}

	@Override
	public String outputCDataAsString(Format format, CDATA cdata) {
		SAXHandler handler = new SAXHandler();
		SAXOutputter saxout = new SAXOutputter(null, format, handler, handler, 
				handler, handler, handler);
		
		try {
			handler.startDocument();
			handler.startElement("", "root", "root", new AttributesImpl());
			saxout.outputFragment(cdata);
			handler.endElement("", "root", "root");
			handler.endDocument();
		} catch (Exception e) {
			throw new IllegalStateException("Could not output", e);
		}
		XMLOutputter xout = new XMLOutputter();
		xout.getFormat().setLineSeparator(LineSeparator.NL);
		return xout.outputString(handler.getDocument().getRootElement().getContent());
	}

	@Override
	public String outputTextAsString(Format format, Text text) {
		SAXHandler handler = new SAXHandler();
		SAXOutputter saxout = new SAXOutputter(null, format, handler, handler, 
				handler, handler, handler);
		
		try {
			handler.startDocument();
			handler.startElement("", "root", "root", new AttributesImpl());
			saxout.outputFragment(text);
			handler.endElement("", "root", "root");
			handler.endDocument();
		} catch (Exception e) {
			throw new IllegalStateException("Could not output", e);
		}
		XMLOutputter xout = new XMLOutputter();
		xout.getFormat().setLineSeparator(LineSeparator.NL);
		return xout.outputString(handler.getDocument().getRootElement().getContent());
	}

	@Override
	public String outputCommentAsString(Format format, Comment comment) {
		SAXHandler handler = new SAXHandler();
		SAXOutputter saxout = new SAXOutputter(null, format, handler, handler, 
				handler, handler, handler);
		
		try {
			handler.startDocument();
			handler.startElement("", "root", "root", new AttributesImpl());
			saxout.outputFragment(comment);
			handler.endElement("", "root", "root");
			handler.endDocument();
		} catch (Exception e) {
			throw new IllegalStateException("Could not output", e);
		}
		XMLOutputter xout = new XMLOutputter();
		xout.getFormat().setLineSeparator(LineSeparator.NL);
		return xout.outputString(handler.getDocument().getRootElement().getContent());
	}

	@Override
	public String outputPIAsString(Format format, ProcessingInstruction pi) {
		SAXHandler handler = new SAXHandler();
		SAXOutputter saxout = new SAXOutputter(null, format, handler, handler, 
				handler, handler, handler);
		
		try {
			handler.startDocument();
			handler.startElement("", "root", "root", new AttributesImpl());
			saxout.outputFragment(pi);
			handler.endElement("", "root", "root");
			handler.endDocument();
		} catch (Exception e) {
			throw new IllegalStateException("Could not output", e);
		}
		XMLOutputter xout = new XMLOutputter();
		xout.getFormat().setLineSeparator(LineSeparator.NL);
		return xout.outputString(handler.getDocument().getRootElement().getContent());
	}

	@Override
	public String outputEntityRefAsString(Format format, EntityRef entity) {
		SAXHandler handler = new SAXHandler();
		SAXOutputter saxout = new SAXOutputter(null, format, handler, handler, 
				handler, handler, handler);
		
		try {
			handler.startDocument();
			handler.startElement("", "root", "root", new AttributesImpl());
			saxout.outputFragment(entity);
			handler.endElement("", "root", "root");
			handler.endDocument();
		} catch (Exception e) {
			throw new IllegalStateException("Could not output", e);
		}
		XMLOutputter xout = new XMLOutputter();
		xout.getFormat().setLineSeparator(LineSeparator.NL);
		return xout.outputString(handler.getDocument().getRootElement().getContent());
	}

	@Override
	public String outputElementContentString(Format format, Element element) {
		SAXHandler handler = new SAXHandler();
		SAXOutputter saxout = new SAXOutputter(null, format, handler, handler, 
				handler, handler, handler);
		
		try {
			saxout.outputFragment(element.getContent());
		} catch (Exception e) {
			throw new IllegalStateException("Could not output", e);
		}
		XMLOutputter xout = new XMLOutputter();
		xout.getFormat().setLineSeparator(LineSeparator.NL);
		return xout.outputString(handler.getDocument().getRootElement());
	}

	
	
	
	@Test
	@Ignore
	@Override
	public void testDocTypeSimpleISS() {
		//Cannot preserve internal subset in DOCTYPE through the round-trip test.
	}
	
	@Parameters public static Collection<Object[]> data(){return Arrays.asList(new Object[][]{{{},{}},{{},{}},{{},{}},{{},{}},{{},{}}});}

	private Object _input;
	private Object _expected;

	public AutoPUT(Object _input, Object _expected) {
		this._input = _input;
		this._expected = _expected;
	}
	
}