package org.jdom2.test.cases.output;

import static org.jdom2.test.util.UnitTestUtil.failException;
import static org.jdom2.test.util.UnitTestUtil.normalizeAttributes;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.io.ByteArrayOutputStream;
import java.io.CharArrayReader;
import java.io.IOException;
import java.io.StringReader;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.List;

import javax.xml.stream.XMLEventFactory;
import javax.xml.stream.XMLEventWriter;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.events.XMLEvent;
import javax.xml.stream.util.XMLEventConsumer;

import org.junit.Ignore;
import org.junit.Test;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import org.xml.sax.ext.DefaultHandler2;

import org.jdom2.Attribute;
import org.jdom2.AttributeType;
import org.jdom2.CDATA;
import org.jdom2.Comment;
import org.jdom2.Content;
import org.jdom2.DocType;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.EntityRef;
import org.jdom2.IllegalDataException;
import org.jdom2.JDOMException;
import org.jdom2.Namespace;
import org.jdom2.ProcessingInstruction;
import org.jdom2.Text;
import org.jdom2.UncheckedJDOMFactory;
import org.jdom2.input.SAXBuilder;
import org.jdom2.input.StAXStreamBuilder;
import org.jdom2.input.sax.SAXHandler;
import org.jdom2.input.stax.DefaultStAXFilter;
import org.jdom2.output.Format;
import org.jdom2.output.Format.TextMode;
import org.jdom2.output.support.AbstractStAXEventProcessor;
import org.jdom2.output.support.StAXEventProcessor;
import org.jdom2.output.SAXOutputter;
import org.jdom2.output.StAXEventOutputter;
import org.jdom2.output.XMLOutputter;
import org.junit.runner.RunWith;
import org.junit.experimental.theories.Theories;
import org.junit.experimental.theories.Theory;
import org.junit.experimental.theories.DataPoints;

@SuppressWarnings("javadoc")
public final @RunWith(Theories.class) class AutoPutTest extends AbstractTestOutputter {

	private static final class OutWrapper {
		private final StringWriter swriter = new StringWriter();
		
		private final StAXEventOutputter stax;
		private final XMLEventWriter xwriter;
		private int from = 0, to = -1;
		
		public OutWrapper(Format format) {
			try {
				xwriter = soutfactory.createXMLEventWriter(swriter);
				stax = new StAXEventOutputter(format);
			} catch (Exception xse) {
				throw new IllegalStateException("Cannot construct: See Cause", xse);
			}
		}
		
		@Override
		public String toString() {
			return to >= 0 ? swriter.getBuffer().substring(from, to) :
				swriter.getBuffer().substring(from);
		}
		
		
		
		public StAXEventOutputter getStax() {
			return stax;
		}

		public void close() {
			try {
				xwriter.close();
			} catch (XMLStreamException e) {
				throw new IllegalStateException("Cannot flush(): See Cause", e);
			}
		}

		public XMLEventWriter getStream() {
			return xwriter;
		}

		public void setDocumentMarkFrom() {
			try {
				xwriter.add(seventfactory.createStartDocument());
				xwriter.add(seventfactory.createCharacters(""));
				xwriter.flush();
			} catch (XMLStreamException e) {
				throw new IllegalStateException("Cannot flush(): See Cause", e);
			}
			from = swriter.getBuffer().length();
		}

		public void setDocumentMarkTo() {
			try {
				xwriter.add(seventfactory.createCharacters(""));
				xwriter.flush();
				to = swriter.getBuffer().length();
				xwriter.add(seventfactory.createEndDocument());
			} catch (XMLStreamException e) {
				throw new IllegalStateException("Cannot flush(): See Cause", e);
			}
		}
		
		public void setElementMarkFrom() {
			try {
				xwriter.add(seventfactory.createStartDocument());
				xwriter.add(seventfactory.createStartElement("", "", "root"));
				xwriter.add(seventfactory.createCharacters(""));
				xwriter.flush();
				from = swriter.getBuffer().length();
			} catch (XMLStreamException e) {
				throw new IllegalStateException("Cannot flush(): See Cause", e);
			}
		}

		public void setElementMarkTo() {
			try {
				xwriter.add(seventfactory.createCharacters(""));
				xwriter.flush();
				to = swriter.getBuffer().length();
				xwriter.add(seventfactory.createEndElement("", "", "root"));
				xwriter.add(seventfactory.createEndDocument());
				xwriter.flush();
				xwriter.close();
			} catch (XMLStreamException e) {
				throw new IllegalStateException("Cannot flush(): See Cause", e);
			}
		}
		
	}
	
	
	private static final class EventStore implements XMLEventConsumer {
		private final ArrayList<XMLEvent> store = new ArrayList<XMLEvent>();
		private final String encoding;
		
		EventStore(String enc) {
			encoding = enc;
		}
		
		@Override
		public void add(XMLEvent event) throws XMLStreamException {
			store.add(event);
		}
		
		@Override
		public String toString() {
			ByteArrayOutputStream sw = new ByteArrayOutputStream();
			try {
				XMLEventWriter xew = soutfactory.createXMLEventWriter(sw, encoding);
				for (XMLEvent x : store) {
					xew.add(x);
				}
				xew.flush();
				xew.close();
				return new String(sw.toByteArray());
			} catch (XMLStreamException e) {
				throw new IllegalStateException("Can't get toString...", e);
			}
			
		}
	}
	
	public TestStAXEventOutputter() {
		super(false, false, true, true, false);
	}
	
	
	@Override
	public String outputDocumentAsString(Format format, Document doc) {
		OutWrapper ow = new OutWrapper(format);
		try {
			ow.getStax().output(doc, ow.getStream());
		} catch (XMLStreamException e) {
			throw new IllegalStateException(e);
		}
		ow.close();
		return ow.toString();
	}




	@Override
	public String outputDocTypeAsString(Format format, DocType doctype) {
		OutWrapper ow = new OutWrapper(format);
		try {
			ow.setDocumentMarkFrom();
			ow.getStax().output(doctype, ow.getStream());
			ow.setDocumentMarkTo();
		} catch (XMLStreamException e) {
			throw new IllegalStateException(e);
		}
		ow.close();
		return ow.toString();
	}

	@Override
	public String outputElementAsString(Format format, Element element) {
		OutWrapper ow = new OutWrapper(format);
		try {
			ow.setDocumentMarkFrom();
			ow.getStax().output(element, ow.getStream());
			ow.setDocumentMarkTo();
		} catch (XMLStreamException e) {
			throw new IllegalStateException(e);
		}
		ow.close();
		return ow.toString();
	}

	@Override
	public String outputListAsString(Format format, List<? extends Content> list) {
		OutWrapper ow = new OutWrapper(format);
		try {
			ow.setElementMarkFrom();
			ow.getStax().output(list, ow.getStream());
			ow.setElementMarkTo();
		} catch (XMLStreamException e) {
			throw new IllegalStateException(e);
		}
		ow.close();
		return ow.toString();
	}

	@Override
	public String outputCDataAsString(Format format, CDATA cdata) {
		OutWrapper ow = new OutWrapper(format);
		try {
			ow.setElementMarkFrom();
			ow.getStax().output(cdata, ow.getStream());
			ow.setElementMarkTo();
		} catch (XMLStreamException e) {
			throw new IllegalStateException(e);
		}
		ow.close();
		return ow.toString();
	}

	@Override
	public String outputTextAsString(Format format, Text text) {
		OutWrapper ow = new OutWrapper(format);
		try {
			ow.setElementMarkFrom();
			ow.getStax().output(text, ow.getStream());
			ow.setElementMarkTo();
		} catch (XMLStreamException e) {
			throw new IllegalStateException(e);
		}
		ow.close();
		return ow.toString();
	}

	@Override
	public String outputCommentAsString(Format format, Comment comment) {
		OutWrapper ow = new OutWrapper(format);
		try {
			ow.setDocumentMarkFrom();
			ow.getStax().output(comment, ow.getStream());
			ow.setDocumentMarkTo();
		} catch (XMLStreamException e) {
			throw new IllegalStateException(e);
		}
		ow.close();
		return ow.toString();
	}

	@Override
	public String outputPIAsString(Format format, ProcessingInstruction pi) {
		OutWrapper ow = new OutWrapper(format);
		try {
			ow.setDocumentMarkFrom();
			ow.getStax().output(pi, ow.getStream());
			ow.setDocumentMarkTo();
		} catch (XMLStreamException e) {
			throw new IllegalStateException(e);
		}
		ow.close();
		return ow.toString();
	}

	@Override
	public String outputEntityRefAsString(Format format, EntityRef entity) {
		OutWrapper ow = new OutWrapper(format);
		try {
			ow.setElementMarkFrom();
			ow.getStax().output(entity, ow.getStream());
			ow.setElementMarkTo();
		} catch (XMLStreamException e) {
			throw new IllegalStateException(e);
		}
		ow.close();
		return ow.toString();
	}

	@Override
	public String outputElementContentString(Format format, Element element) {
		OutWrapper ow = new OutWrapper(format);
		try {
			ow.setElementMarkFrom();
			ow.getStax().outputElementContent(element, ow.getStream());
			ow.setElementMarkTo();
		} catch (XMLStreamException e) {
			throw new IllegalStateException(e);
		}
		ow.close();
		return ow.toString();
	}

	@Theory
	public void autoPutTest(Fixture fixture) throws JDOMException, IOException, XMLStreamException {
      SAXBuilder builder = new SAXBuilder();
      builder.setExpandEntities(true);
      Document doc = builder.build(new StringReader(fixture._input[0]));
      Format format = Format.getCompactFormat().setEncoding("ISO-8859-1");
      StAXEventOutputter outputter = new StAXEventOutputter(format);
      EventStore es = new EventStore("ISO-8859-1");
      outputter.output(doc, es);
      String xml = es.toString();
      assertEquals("<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\r\n" + 
                   fixture._input[1], xml);
    }

    

//	@Test
//	public void testXMLOutputterXMLOutputter() {
//		Format mine = Format.getCompactFormat();
//		StAXEventProcessor xoutp = new StAXEventOutputter().getStAXStream();
//		mine.setEncoding("US-ASCII");
//		// double-construct it.
//		StAXEventOutputter out = new StAXEventOutputter();
//		TestFormat.checkEquals(mine, out.getFormat());
//		assertTrue(xoutp == out.getXMLOutputProcessor());
//	}

	
	
	/*
	 * The following are borrowed from the TestSAXOutputter
	 * The effect is that we compare the StAX string output with the re-parsed
	 * value of the input.
	 */
	
    private void roundTripDocument(Document doc) {
    	StAXEventOutputter xout = new StAXEventOutputter(Format.getRawFormat());
    	// create a String representation of the input.
    	if (doc.hasRootElement()) {
    		normalizeAttributes(doc.getRootElement());
    	}
    	
    	try {
    		EventStore xsw = new EventStore("UTF-8");
        	xout.output(doc, xsw);
        	String expect = xsw.toString();
        	
    		// convert the input to a SAX Stream

        	StAXStreamBuilder sbuilder = new StAXStreamBuilder();
        	
        	char[] chars = expect.toCharArray();
        	CharArrayReader car = new CharArrayReader(chars);
        	XMLStreamReader xsr = sinfactory.createXMLStreamReader(car);
        	
			Document backagain = sbuilder.build(xsr);
			xsr.close();
			
			// get a String representation of the round-trip.
	    	if (backagain.hasRootElement()) {
	    		normalizeAttributes(backagain.getRootElement());
	    	}
    		xsw = new EventStore("UTF-8");
			xout.output(backagain, xsw);
			String actual = xsw.toString();
			
	    	assertEquals(expect, actual);
		} catch (Exception e) {
			failException("Failed to round-trip the document with exception: " 
					+ e.getMessage(), e);
		}
    }
    
    private void roundTripElement(Element emt) {
    	
    	try {
        	StAXEventOutputter xout = new StAXEventOutputter(Format.getRawFormat());

    		EventStore xsw = new EventStore("UTF-8");
        	xout.output(emt, xsw);
        	String expect = xsw.toString();
        	
        	StAXStreamBuilder sbuilder = new StAXStreamBuilder();
        	
        	XMLStreamReader xsr = sinfactory.createXMLStreamReader(new StringReader(expect));
        	assertTrue(xsr.getEventType() == XMLStreamConstants.START_DOCUMENT);
        	assertTrue(xsr.hasNext());
        	xsr.next();
        	
			Element backagain = (Element)sbuilder.fragment(xsr);

			// convert the input to a SAX Stream

    		xsw = new EventStore("UTF-8");
        	xout.output(backagain, xsw);
        	
        	String actual = xsw.toString();
        	assertEquals(expect, actual);
		} catch (Exception e) {
			failException("Failed to round-trip the document with exception: " 
					+ e.getMessage(), e);
		}
    }
    
    private void roundTripFragment(List<Content> content) {
    	try {
        	StAXEventOutputter xout = new StAXEventOutputter(Format.getRawFormat());

    		EventStore xsw = new EventStore("UTF-8");
        	xout.output(content, xsw);
        	String expect = xsw.toString();
        	
        	StAXStreamBuilder sbuilder = new StAXStreamBuilder();
        	
        	XMLStreamReader xsr = sinfactory.createXMLStreamReader(new StringReader(expect));
//        	assertTrue(xsr.getEventType() == XMLStreamConstants.START_DOCUMENT);
//        	assertTrue(xsr.hasNext());
//        	xsr.next();
        	
			List<Content> backagain = sbuilder.buildFragments(xsr, new DefaultStAXFilter());

			// convert the input to a SAX Stream

    		xsw = new EventStore("UTF-8");
        	xout.output(backagain, xsw);
        	
        	String actual = xsw.toString();
        	assertEquals(expect, actual);
		} catch (Exception e) {
			failException("Failed to round-trip the document with exception: " 
					+ e.getMessage(), e);
		}
    	
    }
    
    private void roundTripFragment(Content content) {
    	try {
        	StAXEventOutputter xout = new StAXEventOutputter(Format.getRawFormat());

    		EventStore xsw = new EventStore("UTF-8");
        	switch(content.getCType()) {
        		case CDATA :
                	xout.output((CDATA)content, xsw);
                	break;
        		case Text:
                	xout.output((Text)content, xsw);
                	break;
        		case Comment:
                	xout.output((Comment)content, xsw);
                	break;
        		case DocType:
                	xout.output((DocType)content, xsw);
                	break;
        		case Element:
                	xout.output((Element)content, xsw);
                	break;
        		case EntityRef:
                	xout.output((EntityRef)content, xsw);
                	break;
        		case ProcessingInstruction:
                	xout.output((ProcessingInstruction)content, xsw);
                	break;
        		default:
        			throw new IllegalStateException(content.getCType().toString());
        	}
        	String expect = xsw.toString();
        	
        	StAXStreamBuilder sbuilder = new StAXStreamBuilder();
        	
			Content backagain = sbuilder.fragment(
					sinfactory.createXMLStreamReader(new StringReader(expect)));

			// convert the input to a SAX Stream

    		xsw = new EventStore("UTF-8");
        	switch(content.getCType()) {
        		case CDATA :
                	xout.output((CDATA)backagain, xsw);
                	break;
        		case Text:
                	xout.output((Text)backagain, xsw);
                	break;
        		case Comment:
                	xout.output((Comment)backagain, xsw);
                	break;
        		case DocType:
                	xout.output((DocType)backagain, xsw);
                	break;
        		case Element:
                	xout.output((Element)backagain, xsw);
                	break;
        		case EntityRef:
                	xout.output((EntityRef)backagain, xsw);
                	break;
        		case ProcessingInstruction:
                	xout.output((ProcessingInstruction)backagain, xsw);
                	break;
        		default:
        			throw new IllegalStateException(backagain.getCType().toString());
        	}
        	
        	String actual = xsw.toString();
        	assertEquals(expect, actual);
		} catch (Exception e) {
			failException("Failed to round-trip the document with exception: " 
					+ e.getMessage(), e);
		}
    }
    
	private static String[] INPUT1 = { "<?xml version=\"1.0\"?><root>&#x10000; &#65536;</root>",
			"<root>&#xd800;&#xdc00; &#xd800;&#xdc00;</root>\r\n" };

	private static String[] EXPECTED1 = null;

	private static String[] INPUT2 = { "<?xml version=\"1.0\"?><root att=\"&#x10000; &#x10000;\" />",
			"<root att=\"&#xd800;&#xdc00; &#xd800;&#xdc00;\"></root>\r\n" };

	private static String[] EXPECTED2 = null;

	private static String[] INPUT3 = { "<?xml version=\"1.0\"?><root att=\"&#x10000; &#65536;\" />",
			"<root att=\"&#xd800;&#xdc00; &#xd800;&#xdc00;\"></root>\r\n" };

	private static String[] EXPECTED3 = null;

	private static String[] INPUT4 = { "<?xml version=\"1.0\"?><root>\uD800\uDC00</root>",
			"<root>&#xd800;&#xdc00;</root>\r\n" };

	private static String[] EXPECTED4 = null;

	@DataPoints public static Fixture[] DATA={new Fixture(INPUT1,EXPECTED1),new Fixture(INPUT2,EXPECTED2),new Fixture(INPUT3,EXPECTED3),new Fixture(INPUT4,EXPECTED4)};

	public static class Fixture {
		private String[] _input;
		private Object _expected;

		public Fixture(String[] _input, Object _expected) {
			this._input = _input;
			this._expected = _expected;
		}
	}

    
}