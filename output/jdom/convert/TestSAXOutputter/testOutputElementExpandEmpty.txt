package org.jdom2.test.cases.output;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import org.junit.Ignore;
import org.junit.Test;
import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.DTDHandler;
import org.xml.sax.EntityResolver;
import org.xml.sax.ErrorHandler;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.SAXParseException;
import org.xml.sax.ext.DeclHandler;
import org.xml.sax.ext.DefaultHandler2;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.helpers.AttributesImpl;
import org.xml.sax.helpers.LocatorImpl;

import org.jdom2.Attribute;
import org.jdom2.AttributeType;
import org.jdom2.CDATA;
import org.jdom2.Comment;
import org.jdom2.Content;
import org.jdom2.DocType;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.EntityRef;
import org.jdom2.JDOMException;
import org.jdom2.Namespace;
import org.jdom2.ProcessingInstruction;
import org.jdom2.Text;
import org.jdom2.input.sax.SAXHandler;
import org.jdom2.output.Format;
import org.jdom2.output.JDOMLocator;
import org.jdom2.output.LineSeparator;
import org.jdom2.output.SAXOutputter;
import org.jdom2.output.XMLOutputter;
import org.jdom2.output.support.AbstractSAXOutputProcessor;
import org.jdom2.output.support.SAXOutputProcessor;
import org.jdom2.test.util.UnitTestUtil;
import org.junit.runner.RunWith;
import org.junit.experimental.theories.Theories;
import org.junit.experimental.theories.Theory;
import org.junit.experimental.theories.DataPoints;


@SuppressWarnings("javadoc")
public @RunWith(Theories.class) class AutoPutTest extends AbstractTestOutputter {
	
    private interface SAXSetup {
    	public SAXOutputter buildOutputter(SAXHandler handler);
    }
    
    

    /**
	 * @param cr2xD
	 * @param padpreempty
	 * @param padpi
	 * @param forceexpand
	 * @param forceplatformeol
	 */
	public AutoPutTest() {
		super(true, true, false, false, true);
	}

	private void roundTrip(Document doc) {
    	roundTrip(null, doc);
    }
    
    private void roundTrip(SAXSetup setup, Document doc) {
    	XMLOutputter xout = new XMLOutputter(Format.getRawFormat());
    	// create a String representation of the input.
    	if (doc.hasRootElement()) {
    		UnitTestUtil.normalizeAttributes(doc.getRootElement());
    	}
    	String expect = xout.outputString(doc);
    	
    	String actual = null;
    	try {
    		// convert the input to a SAX Stream
    		SAXHandler handler = new SAXHandler();
        	SAXOutputter saxout = setup == null 
        			? new SAXOutputter(handler, handler, handler, handler, handler) 
        			: setup.buildOutputter(handler);

        	saxout.output(doc);
        	
			Document backagain = handler.getDocument();
			
			// get a String representation of the round-trip.
	    	if (backagain.hasRootElement()) {
	    		UnitTestUtil.normalizeAttributes(backagain.getRootElement());
	    	}
			actual = xout.outputString(backagain);
		} catch (JDOMException e) {
			e.printStackTrace();
			fail("Failed to round-trip the document with exception: " 
					+ e.getMessage() + "\n" + expect);
		}
    	assertEquals(expect, actual);
    }
    
    private void roundTrip(SAXSetup setup, Element emt) {
    	XMLOutputter xout = new XMLOutputter(Format.getRawFormat());
    	Document tstdoc = new Document();
    	tstdoc.addContent(emt.clone());
    	String expect = xout.outputString(tstdoc);
    	
    	String actual = null;
    	try {
    		// convert the input to a SAX Stream
    		SAXHandler handler = new SAXHandler();
        	SAXOutputter saxout = setup == null 
        			? new SAXOutputter(handler, handler, handler, handler, handler) 
        			: setup.buildOutputter(handler);

        	saxout.output(emt);
        	
			Document backagain = handler.getDocument();
			
			// get a String representation of the round-trip.
	    	if (backagain.hasRootElement()) {
	    		UnitTestUtil.normalizeAttributes(backagain.getRootElement());
	    	}
			actual = xout.outputString(backagain);
		} catch (JDOMException e) {
			e.printStackTrace();
			fail("Failed to round-trip the document with exception: " 
					+ e.getMessage() + "\n" + expect);
		}
    	assertEquals(expect, actual);
    }
    
    private void roundTripFragment(SAXSetup setup, List<Content> content) {
    	XMLOutputter xout = new XMLOutputter(Format.getRawFormat());
    	Element root = new Element("root");
    	Document tstdoc = new Document(root);
    	
    	for (Content c : content) {
    		root.addContent(c);
    	}
    	
    	String expect = xout.outputString(tstdoc);
    	
    	String actual = null;
    	try {
    		// convert the input to a SAX Stream
    		SAXHandler handler = new SAXHandler();
        	SAXOutputter saxout = setup == null 
        			? new SAXOutputter(handler, handler, handler, handler, handler) 
        			: setup.buildOutputter(handler);

        	Locator loc = new LocatorImpl();
        	handler.setDocumentLocator(loc);
        	handler.startDocument();
        	handler.startElement("", "root", "root", new AttributesImpl());
        	saxout.outputFragment(content);
        	handler.endElement("", "root", "root");
        	handler.endDocument();
        	
			Document backagain = handler.getDocument();
			
			// get a String representation of the round-trip.
	    	if (backagain.hasRootElement()) {
	    		UnitTestUtil.normalizeAttributes(backagain.getRootElement());
	    	}
			actual = xout.outputString(backagain);
		} catch (Exception e) {
			e.printStackTrace();
			fail("Failed to round-trip the document with exception: " 
					+ e.getMessage() + "\n" + expect);
		}
    	assertEquals(expect, actual);
    }
    
    private void roundTripFragment(SAXSetup setup, Content content) {
    	XMLOutputter xout = new XMLOutputter(Format.getRawFormat());
    	Element root = new Element("root");
    	Document tstdoc = new Document(root);
    	
   		root.addContent(content);
    	
    	String expect = xout.outputString(tstdoc);
    	
    	String actual = null;
    	try {
    		// convert the input to a SAX Stream
    		SAXHandler handler = new SAXHandler();
        	SAXOutputter saxout = setup == null 
        			? new SAXOutputter(handler, handler, handler, handler, handler) 
        			: setup.buildOutputter(handler);

        	Locator loc = new LocatorImpl();
        	handler.setDocumentLocator(loc);
        	handler.startDocument();
        	handler.startElement("", "root", "root", new AttributesImpl());
        	saxout.outputFragment(content);
        	handler.endElement("", "root", "root");
        	handler.endDocument();
        	
			Document backagain = handler.getDocument();
			
			// get a String representation of the round-trip.
	    	if (backagain.hasRootElement()) {
	    		UnitTestUtil.normalizeAttributes(backagain.getRootElement());
	    	}
			actual = xout.outputString(backagain);
		} catch (Exception e) {
			e.printStackTrace();
			fail("Failed to round-trip the document with exception: " 
					+ e.getMessage() + "\n" + expect);
		}
    	assertEquals(expect, actual);
    }
    
    private void roundTrip(SAXSetup setup, List<? extends Content> content) {
    	XMLOutputter xout = new XMLOutputter(Format.getRawFormat());
    	Document tstdoc = new Document();
    	for (Object o : content) {
    		tstdoc.addContent((Content)o);
    	}
    	String expect = xout.outputString(tstdoc);
    	
    	String actual = null;
    	try {
    		// convert the input to a SAX Stream
    		SAXHandler handler = new SAXHandler();
        	SAXOutputter saxout = setup == null 
        			? new SAXOutputter(handler, handler, handler, handler, handler) 
        			: setup.buildOutputter(handler);

        	saxout.output(content);
        	
			Document backagain = handler.getDocument();
			
			// get a String representation of the round-trip.
	    	if (backagain.hasRootElement()) {
	    		UnitTestUtil.normalizeAttributes(backagain.getRootElement());
	    	}
			actual = xout.outputString(backagain);
		} catch (JDOMException e) {
			e.printStackTrace();
			fail("Failed to round-trip the document with exception: " 
					+ e.getMessage() + "\n" + expect);
		}
    	assertEquals(expect, actual);
    }
    

	@Override
	public String outputDocumentAsString(Format format, Document doc) {
		SAXHandler handler = new SAXHandler();
		SAXOutputter saxout = new SAXOutputter(null, format, handler, handler, 
				handler, handler, handler);
		try {
			saxout.output(doc);
		} catch (Exception e) {
			throw new IllegalStateException("Could not output", e);
		}
		XMLOutputter xout = new XMLOutputter();
		xout.getFormat().setLineSeparator(LineSeparator.NL);
		return xout.outputString(handler.getDocument());
	}

	@Override
	public String outputDocTypeAsString(Format format, DocType doctype) {
		SAXHandler handler = new SAXHandler();
		SAXOutputter saxout = new SAXOutputter(null, format, handler, handler, 
				handler, handler, handler);
		List<Content> list = new ArrayList<Content>(1);
		list.add(doctype);
		//list.add(new Element("root"));
		
		try {
			saxout.output(list);
		} catch (Exception e) {
			throw new IllegalStateException("Could not output", e);
		}
		XMLOutputter xout = new XMLOutputter();
		xout.getFormat().setLineSeparator(LineSeparator.NL);
		return xout.outputString(handler.getDocument().getDocType());
	}

	@Override
	public String outputElementAsString(Format format, Element element) {
		SAXHandler handler = new SAXHandler();
		SAXOutputter saxout = new SAXOutputter(null, format, handler, handler, 
				handler, handler, handler);
		
		try {
			saxout.output(element);
		} catch (Exception e) {
			throw new IllegalStateException("Could not output", e);
		}
		XMLOutputter xout = new XMLOutputter();
		xout.getFormat().setLineSeparator(LineSeparator.NL);
		return xout.outputString(handler.getDocument().getRootElement());
	}

	@Override
	public String outputListAsString(Format format, List<? extends Content> list) {
		SAXHandler handler = new SAXHandler();
		SAXOutputter saxout = new SAXOutputter(null, format, handler, handler, 
				handler, handler, handler);
		
		try {
			handler.startDocument();
			handler.startElement("", "root", "root", new AttributesImpl());
			saxout.outputFragment(list);
			handler.endElement("", "root", "root");
			handler.endDocument();
		} catch (Exception e) {
			throw new IllegalStateException("Could not output", e);
		}
		XMLOutputter xout = new XMLOutputter();
		xout.getFormat().setLineSeparator(LineSeparator.NL);
		return xout.outputString(handler.getDocument().getRootElement().getContent());
	}

	@Override
	public String outputCDataAsString(Format format, CDATA cdata) {
		SAXHandler handler = new SAXHandler();
		SAXOutputter saxout = new SAXOutputter(null, format, handler, handler, 
				handler, handler, handler);
		
		try {
			handler.startDocument();
			handler.startElement("", "root", "root", new AttributesImpl());
			saxout.outputFragment(cdata);
			handler.endElement("", "root", "root");
			handler.endDocument();
		} catch (Exception e) {
			throw new IllegalStateException("Could not output", e);
		}
		XMLOutputter xout = new XMLOutputter();
		xout.getFormat().setLineSeparator(LineSeparator.NL);
		return xout.outputString(handler.getDocument().getRootElement().getContent());
	}

	@Override
	public String outputTextAsString(Format format, Text text) {
		SAXHandler handler = new SAXHandler();
		SAXOutputter saxout = new SAXOutputter(null, format, handler, handler, 
				handler, handler, handler);
		
		try {
			handler.startDocument();
			handler.startElement("", "root", "root", new AttributesImpl());
			saxout.outputFragment(text);
			handler.endElement("", "root", "root");
			handler.endDocument();
		} catch (Exception e) {
			throw new IllegalStateException("Could not output", e);
		}
		XMLOutputter xout = new XMLOutputter();
		xout.getFormat().setLineSeparator(LineSeparator.NL);
		return xout.outputString(handler.getDocument().getRootElement().getContent());
	}

	@Override
	public String outputCommentAsString(Format format, Comment comment) {
		SAXHandler handler = new SAXHandler();
		SAXOutputter saxout = new SAXOutputter(null, format, handler, handler, 
				handler, handler, handler);
		
		try {
			handler.startDocument();
			handler.startElement("", "root", "root", new AttributesImpl());
			saxout.outputFragment(comment);
			handler.endElement("", "root", "root");
			handler.endDocument();
		} catch (Exception e) {
			throw new IllegalStateException("Could not output", e);
		}
		XMLOutputter xout = new XMLOutputter();
		xout.getFormat().setLineSeparator(LineSeparator.NL);
		return xout.outputString(handler.getDocument().getRootElement().getContent());
	}

	@Override
	public String outputPIAsString(Format format, ProcessingInstruction pi) {
		SAXHandler handler = new SAXHandler();
		SAXOutputter saxout = new SAXOutputter(null, format, handler, handler, 
				handler, handler, handler);
		
		try {
			handler.startDocument();
			handler.startElement("", "root", "root", new AttributesImpl());
			saxout.outputFragment(pi);
			handler.endElement("", "root", "root");
			handler.endDocument();
		} catch (Exception e) {
			throw new IllegalStateException("Could not output", e);
		}
		XMLOutputter xout = new XMLOutputter();
		xout.getFormat().setLineSeparator(LineSeparator.NL);
		return xout.outputString(handler.getDocument().getRootElement().getContent());
	}

	@Override
	public String outputEntityRefAsString(Format format, EntityRef entity) {
		SAXHandler handler = new SAXHandler();
		SAXOutputter saxout = new SAXOutputter(null, format, handler, handler, 
				handler, handler, handler);
		
		try {
			handler.startDocument();
			handler.startElement("", "root", "root", new AttributesImpl());
			saxout.outputFragment(entity);
			handler.endElement("", "root", "root");
			handler.endDocument();
		} catch (Exception e) {
			throw new IllegalStateException("Could not output", e);
		}
		XMLOutputter xout = new XMLOutputter();
		xout.getFormat().setLineSeparator(LineSeparator.NL);
		return xout.outputString(handler.getDocument().getRootElement().getContent());
	}

	@Override
	public String outputElementContentString(Format format, Element element) {
		SAXHandler handler = new SAXHandler();
		SAXOutputter saxout = new SAXOutputter(null, format, handler, handler, 
				handler, handler, handler);
		
		try {
			saxout.outputFragment(element.getContent());
		} catch (Exception e) {
			throw new IllegalStateException("Could not output", e);
		}
		XMLOutputter xout = new XMLOutputter();
		xout.getFormat().setLineSeparator(LineSeparator.NL);
		return xout.outputString(handler.getDocument().getRootElement());
	}

	
	
	
	@Theory
	@Override
	@Ignore
	public void autoPutTest(Fixture fixture) {
		// Can't control expand in SAXOutputter.
	}
	
	private static Object INPUT1 = null;

	private static Object EXPECTED1 = null;

	private static Object INPUT2 = null;

	private static Object EXPECTED2 = null;

	private static Object INPUT3 = null;

	private static Object EXPECTED3 = null;

	private static Object INPUT4 = null;

	private static Object EXPECTED4 = null;

	private static Object INPUT5 = null;

	private static Object EXPECTED5 = null;

	private static Object INPUT6 = null;

	private static Object EXPECTED6 = null;

	private static Object INPUT7 = null;

	private static Object EXPECTED7 = null;

	private static Object INPUT8 = null;

	private static Object EXPECTED8 = null;

	private static Object INPUT9 = null;

	private static Object EXPECTED9 = null;

	@DataPoints public static Fixture[] DATA={new Fixture(INPUT1,EXPECTED1),new Fixture(INPUT2,EXPECTED2),new Fixture(INPUT3,EXPECTED3),new Fixture(INPUT4,EXPECTED4),new Fixture(INPUT5,EXPECTED5),new Fixture(INPUT6,EXPECTED6),new Fixture(INPUT7,EXPECTED7),new Fixture(INPUT8,EXPECTED8),new Fixture(INPUT9,EXPECTED9)};

	public static class Fixture {
		private Object _input;
		private Object _expected;

		public Fixture(Object _input, Object _expected) {
			this._input = _input;
			this._expected = _expected;
		}
	}
	
}