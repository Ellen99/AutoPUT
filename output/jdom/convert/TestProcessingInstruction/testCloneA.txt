package org.jdom2.test.cases;

import static org.jdom2.test.util.UnitTestUtil.checkEquals;
import static org.jdom2.test.util.UnitTestUtil.cloneString;
import static org.jdom2.test.util.UnitTestUtil.deSerialize;
import static org.junit.Assert.*;

import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.jdom2.Element;
import org.jdom2.IllegalDataException;
import org.jdom2.IllegalNameException;
import org.jdom2.IllegalTargetException;
import org.jdom2.ProcessingInstruction;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.experimental.theories.Theories;
import org.junit.experimental.theories.Theory;
import org.junit.experimental.theories.DataPoints;

@SuppressWarnings("javadoc")
public @RunWith(Theories.class) class AutoPutTest {

	private void checkMapValues(ProcessingInstruction pi, Map<String, String> vals) {
		for (Map.Entry<String,String> me : vals.entrySet()) {
			checkEquals(pi.getPseudoAttributeValue(me.getKey()), me.getValue());
		}
		for (Object s : pi.getPseudoAttributeNames() ) {
			if (!vals.containsKey(s)) {
				fail("ProcessingInstruction has key " + s + " which is not expected.");
			}
		}
	}
	
	private Map<String,String> buildMap(String...kvpairs) {
		assertTrue(kvpairs != null);
		assertTrue(kvpairs.length % 2 == 0);
		LinkedHashMap<String, String> lhm = new LinkedHashMap<String, String>();
		for (int i = 0; i < kvpairs.length; i += 2) {
			lhm.put(kvpairs[i], kvpairs[i+1]);
		}
		return lhm;
	}

	@Theory
	public void autoPutTest(Fixture fixture) {
		ProcessingInstruction pi = new ProcessingInstruction("test", fixture._input);
		ProcessingInstruction copy = pi.clone();
		assertTrue(!pi.equals(copy));
		checkEquals(pi.getTarget(), copy.getTarget());
		checkEquals(pi.getValue(), copy.getValue());
	}

	private void exercise(Map<String,String> data) {
		exerciseQuotes("'", "'", data);
		exerciseQuotes("\"", "\"", data);
		exerciseQuotes("	\"", "\"	", data);
		exerciseQuotes(" '", "' ", data);
		exerciseQuotes("	'", "'	", data);
		data.put("quote", "Foo'd up!");
		exerciseQuotes("\"", "\"", data);
		data.put("quote", "This is a \"quoted\" value.");
		exerciseQuotes(" '", "' ", data);
		data.remove("quote");
		ProcessingInstruction pi = new ProcessingInstruction("tgt", data);
		for (Map.Entry<String, String> me : data.entrySet()) {
			assertEquals(me.getValue(), pi.getPseudoAttributeValue(me.getKey()));
			assertTrue(pi.removePseudoAttribute(me.getKey()));
			assertFalse(pi.removePseudoAttribute(me.getKey()));
		}
		for (Map.Entry<String, String> me : data.entrySet()) {
			assertTrue(null == pi.getPseudoAttributeValue(me.getKey()));
			assertFalse(pi.removePseudoAttribute(me.getKey()));
			assertTrue(pi == pi.setPseudoAttribute(me.getKey(), me.getValue()));
			assertEquals(me.getValue(), pi.getPseudoAttributeValue(me.getKey()));
		}
		checkEquals(mapValue(data), pi.getData());
		
	}

	private void exerciseQuotes(String open, String close,
			Map<String, String> data) {
		StringBuilder sb = new StringBuilder();
		int cnt = 0;
		for(Map.Entry<String, String> me : data.entrySet()) {
			if (cnt++ > 0) {
				sb.append(" ");
			}
			sb.append(me.getKey()).append("=").append(open).append(me.getValue()).append(close);
		}
		ProcessingInstruction pi = new ProcessingInstruction("test", sb.toString());
		checkEquals(pi.getData(), sb.toString());
		List<?> keys = pi.getPseudoAttributeNames();
		assertTrue(keys != null);
		assertTrue(keys.size() == data.size());
		assertTrue(keys.containsAll(data.keySet()));
		assertTrue(data.keySet().containsAll(keys));
		for (Map.Entry<String,String> me : data.entrySet()) {
			String val = pi.getPseudoAttributeValue(me.getKey());
			assertTrue(val != null);
			String x = me.getValue();
			if (!x.equals(val)) {
				fail("We expected value '" + x + "' but got '" + val + "'.");
			}
		}
		assertEquals(pi.getData(), pi.getValue());
		// ProcessingInstruction does not change the quoting unless you mess with
		// attribute values.
		assertEquals(pi.getData(), pi.getValue());
		pi.setPseudoAttribute("foo", "bar");
		pi.removePseudoAttribute("foo");
		checkEquals(pi.getData(), mapValue(data));
	}
	
	private String mapValue(Map<String,String> data) {
		StringBuilder sb = new StringBuilder();
		for (Map.Entry<String,String> me : data.entrySet()) {
			if (sb.length() > 0) {
				sb.append(" ");
			}
			sb.append(me.getKey()).append("=\"").append(me.getValue()).append("\"");
		}
		return sb.toString();
	}

    private static String INPUT1 = "value";

	private static Object EXPECTED1 = null;

	private static String INPUT2 = "";

	private static Object EXPECTED2 = null;

	@DataPoints public static Fixture[] DATA={new Fixture(INPUT1,EXPECTED1),new Fixture(INPUT2,EXPECTED2)};

	public static class Fixture {
		private String _input;
		private Object _expected;

		public Fixture(String _input, Object _expected) {
			this._input = _input;
			this._expected = _expected;
		}
	}

}