/*--

 Copyright (C) 2012 Jason Hunter & Brett McLaughlin.
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:

 1. Redistributions of source code must retain the above copyright
    notice, this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions, and the disclaimer that follows
    these conditions in the documentation and/or other materials
    provided with the distribution.

 3. The name "JDOM" must not be used to endorse or promote products
    derived from this software without prior written permission.  For
    written permission, please contact <request_AT_jdom_DOT_org>.

 4. Products derived from this software may not be called "JDOM", nor
    may "JDOM" appear in their name, without prior written permission
    from the JDOM Project Management <request_AT_jdom_DOT_org>.

 In addition, we request (but do not require) that you include in the
 end-user documentation provided with the redistribution and/or in the
 software itself an acknowledgement equivalent to the following:
     "This product includes software developed by the
      JDOM Project (http://www.jdom.org/)."
 Alternatively, the acknowledgment may be graphical using the logos
 available at http://www.jdom.org/images/logos.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED.  IN NO EVENT SHALL THE JDOM AUTHORS OR THE PROJECT
 CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 SUCH DAMAGE.

 This software consists of voluntary contributions made by many
 individuals on behalf of the JDOM Project and was originally
 created by Jason Hunter <jhunter_AT_jdom_DOT_org> and
 Brett McLaughlin <brett_AT_jdom_DOT_org>.  For more information
 on the JDOM Project, please see <http://www.jdom.org/>.

 */

package org.jdom2.test.cases.xpath;

import static org.jdom2.test.util.UnitTestUtil.checkException;
import static org.jdom2.test.util.UnitTestUtil.failNoException;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.junit.Test;

import org.jdom2.Attribute;
import org.jdom2.CDATA;
import org.jdom2.Comment;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.EntityRef;
import org.jdom2.JDOMException;
import org.jdom2.Namespace;
import org.jdom2.NamespaceAware;
import org.jdom2.ProcessingInstruction;
import org.jdom2.Text;
import org.jdom2.filter.Filter;
import org.jdom2.filter.Filters;
import org.jdom2.test.util.UnitTestUtil;
import org.jdom2.xpath.XPathBuilder;
import org.jdom2.xpath.XPathDiagnostic;
import org.jdom2.xpath.XPathExpression;
import org.jdom2.xpath.XPathFactory;
import org.junit.runner.RunWith;
import org.junit.experimental.theories.Theories;
import org.junit.experimental.theories.Theory;
import org.junit.experimental.theories.DataPoints;

@SuppressWarnings({"javadoc"})
public abstract @RunWith(Theories.class) class AutoPutTest {
	
	protected final Document doc = new Document();
	
	protected final Comment doccomment = new Comment("doc comment");
	protected final ProcessingInstruction docpi = new ProcessingInstruction("jdomtest", "doc");
	
	protected final Element main = new Element("main");
	protected final Attribute mainatt = new Attribute("atta", "vala");
	protected final Comment maincomment = new Comment("main comment");
	protected final ProcessingInstruction mainpi = new ProcessingInstruction("jdomtest", "pi data");
	protected final Text maintext1 = new Text(" space1 ");
	protected final Element child1emt = new Element("child");
	protected final Text child1text = new Text("child1text");
	protected final Text maintext2 = new Text(" space2 ");
	protected final Element child2emt = new Element("child");
	
	protected final Namespace child3nsa = Namespace.getNamespace("c3nsa", "jdom:c3nsa");
	protected final Namespace child3nsb = Namespace.getNamespace("c3nsb", "jdom:c3nsb");
	protected final Element child3emt = new Element("child", child3nsa);
	protected final Attribute child3attint = new Attribute("intatt", "-123", child3nsb);
	protected final Attribute child3attdoub = new Attribute("doubatt", "-123.45", child3nsb);
	protected final Text child3txt = new Text("c3text");
	
	protected final String mainvalue = " space1 child1text space2 c3text";
	protected final boolean teststring;
	
	public AutoPutTest(boolean teststring) {
		this.teststring = teststring;
		doc.addContent(doccomment);
		doc.addContent(docpi);
		doc.addContent(main);
		main.setAttribute(mainatt);
		main.addContent(maincomment);
		main.addContent(mainpi);
		main.addContent(maintext1);
		child1emt.addContent(child1text);
		main.addContent(child1emt);
		main.addContent(maintext2);
		main.addContent(child2emt);
		child3emt.setAttribute(child3attint);
		child3emt.setAttribute(child3attdoub);
		child3emt.addContent(child3txt);
		main.addContent(child3emt);
	}
	
	/**
	 * Create an instance of an XPath.
	 * Override this method to create the type of XPath instance we want to test.
	 * The method should add the supplied Namspace keys, and set the given variables
	 * on the XPath.
	 * @param path
	 * @param variables
	 * @param namespaces
	 * @return
	 * @throws JDOMException
	 */
	abstract XPathFactory getFactory();
	
	protected <T> XPathExpression<T> setupXPath(Filter<T> filter, String path, Map<String, Object> variables, Object context, Namespace... namespaces) {
		
		XPathBuilder<T> xpath = new XPathBuilder<T>(path, filter);
		
		assertFalse(xpath.equals(null));
		assertFalse(xpath.equals(new Object()));
		UnitTestUtil.checkEquals(xpath, xpath);
		
		assertEquals("getXPath()", path, xpath.getExpression());
		
		
		if (variables != null) {
			for (Map.Entry<String, Object> me : variables.entrySet()) {
				xpath.setVariable(me.getKey(), me.getValue());
			}
		}
		if (context instanceof NamespaceAware) {
			xpath.setNamespaces(((NamespaceAware)context).getNamespacesInScope());
		}
		for (Namespace n : namespaces) {
			xpath.setNamespace(n);
		}
		
		return xpath.compileWith(getFactory());
		
	}
	
	private static final void checkDiagnostic(XPathExpression<?> xpc, Object context, List<?> result, XPathDiagnostic<?> diag) {
		assertTrue(xpc == diag.getXPathExpression());
		assertTrue(context == diag.getContext());
		
		assertTrue(null != diag.toString());
		
		assertFalse(diag.isFirstOnly());
		
		final List<?> dresult = diag.getResult();
		final List<?> draw = diag.getRawResults();
		final List<?> dfilt = diag.getFilteredResults();
		
		assertTrue(dresult.size() == result.size());
		
		for (int i = 0; i < result.size(); i++) {
			assertEquals(dresult.get(i), result.get(i));
		}
		assertTrue(dresult.size() + dfilt.size() == draw.size());
		
		int r = 0;
		int f = 0;
		for (int i = 0; i < draw.size(); i++) {
			if (r < dresult.size() && dresult.get(r) == draw.get(i)) {
				r++;
			} else if (f < dfilt.size() && dfilt.get(f)== draw.get(i)) {
				f++;
			} else {
				fail (draw.get(i) + " is neither a result nor a filtered (or is in the wrong place)");
			}
		}
		
	}
	
	/**
	 * A mechanism for exercising the XPath system.
	 * @param xpath The xpath to run.
	 * @param context The context on which to run the XPath
	 * @param string What we expect the 'xpath' string value of the result to be (or null to skip test).
	 * @param number What we expect the xpath to resolve the result to be as an xpath 'Number' (or null to skip test);
	 * @param expect The nodes we expect from the XPath selectNodes query
	 */
	protected static void checkXPath(XPathExpression<?> xpath, Object context, Object...expect) {
		
		// Check the selectNodes operation.
		List<?> result = xpath.evaluate(context);
		if (result == null) {
			fail ("Got a null result from selectNodes()");
		}
		checkDiagnostic(xpath, context, result, xpath.diagnose(context, false));
		
		boolean allns = true;
		boolean allatts = true;
		for (Object o : expect) {
			if (!(o instanceof Namespace)) {
				allns = false;
				if (!allatts) {
					break;
				}
			}
			if (!(o instanceof Attribute)) {
				allatts = false;
				if (!allns) {
					break;
				}
			}
		}
		
		if (allns && expect.length > 0) {
			// we expect only Namespace results.
			// we use different rules....
			// for a start, we don't check on order.
			// also, if we expect the NO_NAMESPACE, we don't complain if it is
			// not returned.
			int expectsize = expect.length;
			for (Object nso : expect) {
				Namespace ns = (Namespace)nso;
				if (ns == Namespace.NO_NAMESPACE) {
					boolean gotit = false;
					for (Object o : result) {
						if (o == ns) {
							// got it...
							gotit = true;
							break;
						}
					}
					if (!gotit) {
						expectsize--;
					}
				} else {
					boolean gotit = false;
					for (Object o : result) {
						if (o == ns) {
							gotit = true;
							break;
						}
					}
					if (!gotit) {
						fail("Expected to have item " + ns + " returned, but it was not");
					}
				}
			}
			if (expectsize != result.size()) {
				fail ("We expected " + expectsize + " Namespace results. We got " + result.size());
			}
			return;
		}
				
		if (allatts && expect.length > 0) {
			// we expect only Attribute results.
			// we use different rules....
			// for a start, we don't check on order.
			// this really suxks, because it is only to satisfy a bug in Jaxen.
			int expectsize = expect.length;
			for (Object atto : expect) {
				Attribute att = (Attribute)atto;
				boolean gotit = false;
				for (Object o : result) {
					if (o == att) {
						gotit = true;
						break;
					}
				}
				if (!gotit) {
					fail("Expected to have item " + att + " returned, but it was not. Instead we got " + result.toString());
				}
			}
			if (expectsize != result.size()) {
				fail ("We expected " + expectsize + " Attribute results. We got " + result.size());
			}
			return;
		}
				
		String sze = result.size() == expect.length ? "" : 
			(" Also Different Sizes: expect=" + expect.length + " actual=" + result.size());
		int pos = 0;
		for (Object o : result) {
			if (pos >= expect.length) {
				fail ("Results contained additional content at position " + 
						pos + " for xpath '" + xpath + "': " + o + sze);
			}
			if (o != expect[pos]) {
				assertEquals("Failed result at position " + pos + 
						" for xpath '" + xpath + "'." + sze, expect[pos], o);
			}
			pos++;
		}
		if (pos < expect.length) {
			fail ("Results are missing " + (expect.length - pos) + 
					" content at position " + pos + " for xpath '" + xpath + 
					"'. First missing content is: " + expect[pos] + sze);
		}
		
		// Check the selectSingleNode operation.
		Object o = xpath.evaluateFirst(context);
		//checkDiagnostic(Collections.singletonList(o), xpath.diagnose(context, true));
		if (expect.length == 0 && o != null) {
			fail("Expected XPath.selectSingleNode() to return nothing, " +
					"but it returned " + o + sze);
		}
		if (expect.length > 0 && o == null) {
			fail("XPath.selectSingleNode() returned nothing, but it should " +
					"have returned " + expect[0] + sze);
		}
		if (expect.length > 0 && o != expect[0]) {
			assertEquals("XPath.selectSingleNode() was expected to return " + 
					expect[0] + "' but instead it returned '" + o + "'" + sze,
					expect[0], o);
		}
		
	}
	
	protected void checkXPath(String xpath, Object context, String value, Object...expect) {
		checkXPath(setupXPath(Filters.fpassthrough(), xpath, null, context), context, expect);
		if (teststring && value != null) {
			String npath = "string(" + xpath + ")";
			checkXPath(setupXPath(Filters.fstring(), npath, null, context), context, value);
		}
	}

	private void checkComplexXPath(String xpath, Object context, Map<String, Object> variables, 
			Collection<Namespace> namespaces, String value, Number number, Object...expect) {
		HashSet<Namespace> nset = new HashSet<Namespace>();
		if (namespaces != null) {
			nset.addAll(namespaces);
		}
		if (context instanceof NamespaceAware) {
			nset.addAll(((NamespaceAware)context).getNamespacesInScope());
		}
				
		Namespace[] nsa = nset.toArray(new Namespace[0]);
		checkXPath(setupXPath(Filters.fpassthrough(), xpath, variables, context, nsa), context, expect);
		if (teststring && value != null) {
			String npath = "string(" + xpath + ")";
			checkXPath(setupXPath(Filters.fstring(), npath, variables, context, nsa), context, value);
		}
		if (teststring && number != null) {
			String npath = "number(" + xpath + ")";
			checkXPath(setupXPath(Filters.fdouble(), npath, variables, context, nsa), context, number);
		}
	}

//	@Test
//	public void testSerialization() {
//		XPath xpath = setupXPath("//main", null);
//		XPath xser  = UnitTestUtil.deSerialize(xpath);
//		assertTrue(xpath != xser);
//		// TODO JaxenXPath has useless equals(). See issue #43
//		// Additionally, all XPath deserialization is done on the default
//		// factory... will never be equals() if the factory used to create
//		// the xpath is different.
//		// UnitTestUtil.checkEquals(xpath, xser);
//		assertEquals(xpath.toString(), xser.toString());
//	}
	
	@Theory
	public void autoPutTest(Fixture fixture) {
		try {
			Namespace nsa = Namespace.getNamespace("pfx", "one");
			Namespace nsb = Namespace.getNamespace(fixture._input, "two");
			getFactory().compile("/", Filters.element(), null, Namespace.NO_NAMESPACE, nsa, Namespace.XML_NAMESPACE, nsb);
			fail("excpected IAE");
		} catch (IllegalArgumentException noe) {
			// great
		}
	}
	
	

		
	/* *************************************
	 * Boolean/Double/String tests.
	 * ************************************* */
	
	

	/* *************************************
	 * Element tests.
	 * ************************************* */
	
	

	
	/* *************************************
	 * Processing Instruction tests.
	 * ************************************* */
	
	

	/* *************************************
	 * Attribute tests.
	 * ************************************* */
	
	

	/* *************************************
	 * XPath Variable tests.
	 * ************************************* */

	
	
	/* *******************************
	 * Axis TestCases
	 * ******************************* */
	
	
	
	
	/* *******************************
	 * Negative TestCases
	 * ******************************* */
	
	private void checkDetached(final NamespaceAware nsa) {
		checkXPath(".", nsa, null, nsa);
	}
	
	private static String INPUT1 = "pfx";


	private static Object EXPECTED1 = null;


	private static String INPUT2 = "";


	private static Object EXPECTED2 = null;


	@DataPoints public static Fixture[] DATA={new Fixture(INPUT1,EXPECTED1),new Fixture(INPUT2,EXPECTED2)};


	public static class Fixture {
		private String _input;
		private Object _expected;

		public Fixture(String _input, Object _expected) {
			this._input = _input;
			this._expected = _expected;
		}
	}
	
}