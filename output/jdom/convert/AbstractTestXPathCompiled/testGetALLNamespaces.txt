/*--

 Copyright (C) 2012 Jason Hunter & Brett McLaughlin.
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:

 1. Redistributions of source code must retain the above copyright
    notice, this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions, and the disclaimer that follows
    these conditions in the documentation and/or other materials
    provided with the distribution.

 3. The name "JDOM" must not be used to endorse or promote products
    derived from this software without prior written permission.  For
    written permission, please contact <request_AT_jdom_DOT_org>.

 4. Products derived from this software may not be called "JDOM", nor
    may "JDOM" appear in their name, without prior written permission
    from the JDOM Project Management <request_AT_jdom_DOT_org>.

 In addition, we request (but do not require) that you include in the
 end-user documentation provided with the redistribution and/or in the
 software itself an acknowledgement equivalent to the following:
     "This product includes software developed by the
      JDOM Project (http://www.jdom.org/)."
 Alternatively, the acknowledgment may be graphical using the logos
 available at http://www.jdom.org/images/logos.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED.  IN NO EVENT SHALL THE JDOM AUTHORS OR THE PROJECT
 CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 SUCH DAMAGE.

 This software consists of voluntary contributions made by many
 individuals on behalf of the JDOM Project and was originally
 created by Jason Hunter <jhunter_AT_jdom_DOT_org> and
 Brett McLaughlin <brett_AT_jdom_DOT_org>.  For more information
 on the JDOM Project, please see <http://www.jdom.org/>.

 */

package org.jdom2.test.cases.xpath;

import static org.jdom2.test.util.UnitTestUtil.checkException;
import static org.jdom2.test.util.UnitTestUtil.failNoException;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.junit.Test;

import org.jdom2.Attribute;
import org.jdom2.CDATA;
import org.jdom2.Comment;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.EntityRef;
import org.jdom2.JDOMException;
import org.jdom2.Namespace;
import org.jdom2.NamespaceAware;
import org.jdom2.ProcessingInstruction;
import org.jdom2.Text;
import org.jdom2.filter.Filter;
import org.jdom2.filter.Filters;
import org.jdom2.test.util.UnitTestUtil;
import org.jdom2.xpath.XPathBuilder;
import org.jdom2.xpath.XPathDiagnostic;
import org.jdom2.xpath.XPathExpression;
import org.jdom2.xpath.XPathFactory;
import org.junit.runner.RunWith;
import org.junit.experimental.theories.Theories;
import org.junit.experimental.theories.Theory;
import org.junit.experimental.theories.DataPoints;

@SuppressWarnings({"javadoc"})
public abstract @RunWith(Theories.class) class AutoPutTest {
	
	public AbstractTestXPathCompiled(boolean teststring) {
		this.teststring = teststring;
		doc.addContent(doccomment);
		doc.addContent(docpi);
		doc.addContent(main);
		main.setAttribute(mainatt);
		main.addContent(maincomment);
		main.addContent(mainpi);
		main.addContent(maintext1);
		child1emt.addContent(child1text);
		main.addContent(child1emt);
		main.addContent(maintext2);
		main.addContent(child2emt);
		child3emt.setAttribute(child3attint);
		child3emt.setAttribute(child3attdoub);
		child3emt.addContent(child3txt);
		main.addContent(child3emt);
	}
	
	/**
	 * Create an instance of an XPath.
	 * Override this method to create the type of XPath instance we want to test.
	 * The method should add the supplied Namspace keys, and set the given variables
	 * on the XPath.
	 * @param path
	 * @param variables
	 * @param namespaces
	 * @return
	 * @throws JDOMException
	 */
	abstract XPathFactory getFactory();
	
	protected <T> XPathExpression<T> setupXPath(Filter<T> filter, String path, Map<String, Object> variables, Object context, Namespace... namespaces) {
		
		XPathBuilder<T> xpath = new XPathBuilder<T>(path, filter);
		
		assertFalse(xpath.equals(null));
		assertFalse(xpath.equals(new Object()));
		UnitTestUtil.checkEquals(xpath, xpath);
		
		assertEquals("getXPath()", path, xpath.getExpression());
		
		
		if (variables != null) {
			for (Map.Entry<String, Object> me : variables.entrySet()) {
				xpath.setVariable(me.getKey(), me.getValue());
			}
		}
		if (context instanceof NamespaceAware) {
			xpath.setNamespaces(((NamespaceAware)context).getNamespacesInScope());
		}
		for (Namespace n : namespaces) {
			xpath.setNamespace(n);
		}
		
		return xpath.compileWith(getFactory());
		
	}
	
	private static final void checkDiagnostic(XPathExpression<?> xpc, Object context, List<?> result, XPathDiagnostic<?> diag) {
		assertTrue(xpc == diag.getXPathExpression());
		assertTrue(context == diag.getContext());
		
		assertTrue(null != diag.toString());
		
		assertFalse(diag.isFirstOnly());
		
		final List<?> dresult = diag.getResult();
		final List<?> draw = diag.getRawResults();
		final List<?> dfilt = diag.getFilteredResults();
		
		assertTrue(dresult.size() == result.size());
		
		for (int i = 0; i < result.size(); i++) {
			assertEquals(dresult.get(i), result.get(i));
		}
		assertTrue(dresult.size() + dfilt.size() == draw.size());
		
		int r = 0;
		int f = 0;
		for (int i = 0; i < draw.size(); i++) {
			if (r < dresult.size() && dresult.get(r) == draw.get(i)) {
				r++;
			} else if (f < dfilt.size() && dfilt.get(f)== draw.get(i)) {
				f++;
			} else {
				fail (draw.get(i) + " is neither a result nor a filtered (or is in the wrong place)");
			}
		}
		
	}
	
	/**
	 * A mechanism for exercising the XPath system.
	 * @param xpath The xpath to run.
	 * @param context The context on which to run the XPath
	 * @param string What we expect the 'xpath' string value of the result to be (or null to skip test).
	 * @param number What we expect the xpath to resolve the result to be as an xpath 'Number' (or null to skip test);
	 * @param expect The nodes we expect from the XPath selectNodes query
	 */
	protected static void checkXPath(XPathExpression<?> xpath, Object context, Object...expect) {
		
		// Check the selectNodes operation.
		List<?> result = xpath.evaluate(context);
		if (result == null) {
			fail ("Got a null result from selectNodes()");
		}
		checkDiagnostic(xpath, context, result, xpath.diagnose(context, false));
		
		boolean allns = true;
		boolean allatts = true;
		for (Object o : expect) {
			if (!(o instanceof Namespace)) {
				allns = false;
				if (!allatts) {
					break;
				}
			}
			if (!(o instanceof Attribute)) {
				allatts = false;
				if (!allns) {
					break;
				}
			}
		}
		
		if (allns && expect.length > 0) {
			// we expect only Namespace results.
			// we use different rules....
			// for a start, we don't check on order.
			// also, if we expect the NO_NAMESPACE, we don't complain if it is
			// not returned.
			int expectsize = expect.length;
			for (Object nso : expect) {
				Namespace ns = (Namespace)nso;
				if (ns == Namespace.NO_NAMESPACE) {
					boolean gotit = false;
					for (Object o : result) {
						if (o == ns) {
							// got it...
							gotit = true;
							break;
						}
					}
					if (!gotit) {
						expectsize--;
					}
				} else {
					boolean gotit = false;
					for (Object o : result) {
						if (o == ns) {
							gotit = true;
							break;
						}
					}
					if (!gotit) {
						fail("Expected to have item " + ns + " returned, but it was not");
					}
				}
			}
			if (expectsize != result.size()) {
				fail ("We expected " + expectsize + " Namespace results. We got " + result.size());
			}
			return;
		}
				
		if (allatts && expect.length > 0) {
			// we expect only Attribute results.
			// we use different rules....
			// for a start, we don't check on order.
			// this really suxks, because it is only to satisfy a bug in Jaxen.
			int expectsize = expect.length;
			for (Object atto : expect) {
				Attribute att = (Attribute)atto;
				boolean gotit = false;
				for (Object o : result) {
					if (o == att) {
						gotit = true;
						break;
					}
				}
				if (!gotit) {
					fail("Expected to have item " + att + " returned, but it was not. Instead we got " + result.toString());
				}
			}
			if (expectsize != result.size()) {
				fail ("We expected " + expectsize + " Attribute results. We got " + result.size());
			}
			return;
		}
				
		String sze = result.size() == expect.length ? "" : 
			(" Also Different Sizes: expect=" + expect.length + " actual=" + result.size());
		int pos = 0;
		for (Object o : result) {
			if (pos >= expect.length) {
				fail ("Results contained additional content at position " + 
						pos + " for xpath '" + xpath + "': " + o + sze);
			}
			if (o != expect[pos]) {
				assertEquals("Failed result at position " + pos + 
						" for xpath '" + xpath + "'." + sze, expect[pos], o);
			}
			pos++;
		}
		if (pos < expect.length) {
			fail ("Results are missing " + (expect.length - pos) + 
					" content at position " + pos + " for xpath '" + xpath + 
					"'. First missing content is: " + expect[pos] + sze);
		}
		
		// Check the selectSingleNode operation.
		Object o = xpath.evaluateFirst(context);
		//checkDiagnostic(Collections.singletonList(o), xpath.diagnose(context, true));
		if (expect.length == 0 && o != null) {
			fail("Expected XPath.selectSingleNode() to return nothing, " +
					"but it returned " + o + sze);
		}
		if (expect.length > 0 && o == null) {
			fail("XPath.selectSingleNode() returned nothing, but it should " +
					"have returned " + expect[0] + sze);
		}
		if (expect.length > 0 && o != expect[0]) {
			assertEquals("XPath.selectSingleNode() was expected to return " + 
					expect[0] + "' but instead it returned '" + o + "'" + sze,
					expect[0], o);
		}
		
	}
	
	protected void checkXPath(String xpath, Object context, String value, Object...expect) {
		checkXPath(setupXPath(Filters.fpassthrough(), xpath, null, context), context, expect);
		if (teststring && value != null) {
			String npath = "string(" + xpath + ")";
			checkXPath(setupXPath(Filters.fstring(), npath, null, context), context, value);
		}
	}

	private void checkComplexXPath(String xpath, Object context, Map<String, Object> variables, 
			Collection<Namespace> namespaces, String value, Number number, Object...expect) {
		HashSet<Namespace> nset = new HashSet<Namespace>();
		if (namespaces != null) {
			nset.addAll(namespaces);
		}
		if (context instanceof NamespaceAware) {
			nset.addAll(((NamespaceAware)context).getNamespacesInScope());
		}
				
		Namespace[] nsa = nset.toArray(new Namespace[0]);
		checkXPath(setupXPath(Filters.fpassthrough(), xpath, variables, context, nsa), context, expect);
		if (teststring && value != null) {
			String npath = "string(" + xpath + ")";
			checkXPath(setupXPath(Filters.fstring(), npath, variables, context, nsa), context, value);
		}
		if (teststring && number != null) {
			String npath = "number(" + xpath + ")";
			checkXPath(setupXPath(Filters.fdouble(), npath, variables, context, nsa), context, number);
		}
	}

//	@Test
//	public void testSerialization() {
//		XPath xpath = setupXPath("//main", null);
//		XPath xser  = UnitTestUtil.deSerialize(xpath);
//		assertTrue(xpath != xser);
//		// TODO JaxenXPath has useless equals(). See issue #43
//		// Additionally, all XPath deserialization is done on the default
//		// factory... will never be equals() if the factory used to create
//		// the xpath is different.
//		// UnitTestUtil.checkEquals(xpath, xser);
//		assertEquals(xpath.toString(), xser.toString());
//	}
	
	

		
	/* *************************************
	 * Boolean/Double/String tests.
	 * ************************************* */
	
	@Test
	public void getXPathDouble() {
		checkXPath("count( //* )", doc, null, Double.valueOf(4));
	}

	@Test
	public void getXPathString() {
		checkXPath("string( . )", child1emt, null, child1text.getText());
	}

	@Test
	public void getXPathBoolean() {
		checkXPath("count (//*) > 1", child1emt, null, Boolean.TRUE);
	}

	/* *************************************
	 * Element tests.
	 * ************************************* */
	
	@Test
	public void getXPathElementName() {
		checkXPath("//*[name() = 'main']", doc, null, main);
	}

	@Test
	public void getXPathElementText() {
		checkXPath("//*[string() = 'child1text']", doc, null, child1emt);
	}

	
	/* *************************************
	 * Processing Instruction tests.
	 * ************************************* */
	
	@Test
	public void getXPathProcessingInstructionAll() {
		checkXPath("//processing-instruction()", doc, null, docpi, mainpi);
	}

	@Test
	public void getXPathProcessingInstructionByTarget() {
		checkXPath("//processing-instruction()[name() = 'jdomtest']", doc, null, docpi, mainpi);
	}

	@Test
	public void getXPathProcessingInstructionByData() {
		checkXPath("//processing-instruction()[string() = 'doc']", doc, null, docpi);
	}

	/* *************************************
	 * Attribute tests.
	 * ************************************* */
	
	@Test
	public void getXPathAttributeAll() {
		checkXPath("//@*", doc, null, mainatt, child3attint, child3attdoub);
	}

	@Test
	public void getXPathAttributeByName() {
		checkXPath("//@*[name() = 'atta']", doc, null, mainatt);
	}

	@Test
	public void getXPathAttributeByValue() {
		checkXPath("//@*[string() = '-123']", doc, null, child3attint);
	}

	/* *************************************
	 * XPath Variable tests.
	 * ************************************* */

	@Theory
	public void autoPutTest(Fixture fixture) {
		//Namespace.NO_NAMESPACE is declared earlier in documentOrder.
		// so it comes first.
		// we do not specify which Namespace should be first....
		checkXPath(_input.fixture, child3emt, null, 
				child3nsa, Namespace.NO_NAMESPACE, child3nsb, Namespace.XML_NAMESPACE);
	}
	
	
	
	/* *******************************
	 * Axis TestCases
	 * ******************************* */
	
	
	
	
	/* *******************************
	 * Negative TestCases
	 * ******************************* */
	
	private void checkDetached(final NamespaceAware nsa) {
		checkXPath(".", nsa, null, nsa);
	}
	
	private static String INPUT1 = "//c3nsa:child/namespace::*";


	private static String EXPECTED1 = null;


	private static String INPUT2 = "namespace::*";


	private static String EXPECTED2 = null;


	@DataPoints public static Fixture[] DATA={new Fixture(INPUT1,EXPECTED1),new Fixture(INPUT2,EXPECTED2)};


	public static class Fixture {
		private String _input;
		private Object _expected;

		public Fixture(String _input, Object _expected) {
			this._input = _input;
			this._expected = _expected;
		}
	}
	
}