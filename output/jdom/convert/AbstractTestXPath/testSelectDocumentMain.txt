package org.jdom2.test.cases.xpath;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.jdom2.Attribute;
import org.jdom2.Comment;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.JDOMException;
import org.jdom2.Namespace;
import org.jdom2.ProcessingInstruction;
import org.jdom2.Text;
import org.jdom2.test.util.UnitTestUtil;
import org.jdom2.xpath.XPath;

import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.experimental.theories.Theories;
import org.junit.experimental.theories.Theory;
import org.junit.experimental.theories.DataPoints;

/**
 * 
 * @author Rolf Lear
 * @deprecated replaced by XPathExpression
 */
@SuppressWarnings({"javadoc"})
@Deprecated
public abstract @RunWith(Theories.class) class AutoPutTest {
	
	public AbstractTestXPath() {
		doc.addContent(doccomment);
		doc.addContent(docpi);
		doc.addContent(main);
		main.setAttribute(mainatt);
		main.addContent(maincomment);
		main.addContent(mainpi);
		main.addContent(maintext1);
		child1emt.addContent(child1text);
		main.addContent(child1emt);
		main.addContent(maintext2);
		main.addContent(child2emt);
		child3emt.setAttribute(child3attint);
		child3emt.setAttribute(child3attdoub);
		child3emt.addContent(child3txt);
		main.addContent(child3emt);
	}
	
	/**
	 * Create an instance of an XPath.
	 * Override this method to create the type of XPath instance we want to test.
	 * The method should add the supplied Namspace keys, and set the given variables
	 * on the XPath.
	 * @param path
	 * @param variables
	 * @param namespaces
	 * @return
	 * @throws JDOMException
	 */
	abstract XPath buildPath(String path) throws JDOMException;
	
	private XPath setupXPath(String path, Map<String, Object> variables, Namespace... namespaces) {
		
		XPath xpath = null;
		
		try {
			xpath = buildPath(path);
			
			assertTrue(xpath != null);
			
			assertFalse(xpath.equals(null));
			assertFalse(xpath.equals(new Object()));
			UnitTestUtil.checkEquals(xpath, xpath);
			
			assertEquals("getXPath()", path, xpath.getXPath());
			
			
			if (variables != null) {
				for (Map.Entry<String, Object> me : variables.entrySet()) {
					xpath.setVariable(me.getKey(), me.getValue());
				}
			}
			for (Namespace n : namespaces) {
				xpath.addNamespace(n);
			}
		} catch (JDOMException jde) {
			jde.printStackTrace();
			fail("Unable to create XPath " + path);
		}
		return xpath;
		
	}
	
	/**
	 * A mechanism for exercising the XPath system.
	 * @param xpath The xpath to run.
	 * @param context The context on which to run the XPath
	 * @param string What we expect the 'xpath' string value of the result to be (or null to skip test).
	 * @param number What we expect the xpath to resolve the result to be as an xpath 'Number' (or null to skip test);
	 * @param expect The nodes we expect from the XPath selectNodes query
	 */
	private static void checkXPath(XPath xpath, Object context, String value, Number number, Object...expect) {
		try {
			
			// Check the selectNodes operation.
			List<?> result = xpath.selectNodes(context);
			if (result == null) {
				fail ("Got a null result from selectNodes()");
			}
			String sze = result.size() == expect.length ? "" : 
				(" Also Different Sizes: expect=" + expect.length + " actual=" + result.size());
			int pos = 0;
			for (Object o : result) {
				if (pos >= expect.length) {
					fail ("Results contained additional content at position " + 
							pos + " for xpath '" + xpath + "': " + o + sze);
				}
				if (o != expect[pos]) {
					assertEquals("Failed result at position " + pos + 
							" for xpath '" + xpath + "'." + sze, expect[pos], o);
				}
				pos++;
			}
			if (pos < expect.length) {
				fail ("Results are missing " + (expect.length - pos) + 
						" content at position " + pos + " for xpath '" + xpath + 
						"'. First missing content is: " + expect[pos] + sze);
			}
			
			// Check the selectSingleNode operation.
			Object o = xpath.selectSingleNode(context);
			if (expect.length == 0 && o != null) {
				fail("Expected XPath.selectSingleNode() to return nothing, " +
						"but it returned " + o + sze);
			}
			if (expect.length > 0 && o == null) {
				fail("XPath.selectSingleNode() returned nothing, but it should " +
						"have returned " + expect[0] + sze);
			}
			if (expect.length > 0 && o != expect[0]) {
				assertEquals("XPath.selectSingleNode() was expected to return " + 
						expect[0] + "' but instead it returned '" + o + "'" + sze,
						expect[0], o);
			}
			
			// Check the getValue() operation
			String gotstring = xpath.valueOf(context);
			if (value != null) {
				assertEquals("Checking valueOf()", value, gotstring);
			}
			
			// check numberValue()
			if (number == null) {
				// we do the check, ignore the result, including exceptions.
				try {
					xpath.numberValueOf(context);
					// Great too!
				} catch (JDOMException jde) {
					// OK, ignore it....
				} catch (Exception e) {
					e.printStackTrace();
					fail ("Expecting a value or  JDOMException from numberValueOf(), but got " + e.getClass());
				}
			} else {
				Number gotval = xpath.numberValueOf(context);
				if (!number.equals(gotval)) {
					assertEquals("Numbers fail to compare!", number, gotval);
				}
			}
			
//			if (expect.length == 0 && o != null) {
//				fail("Expected XPath.selectSingleNode() to return nothing, " +
//						"but it returned " + o);
//			}
//			if (expect.length > 0 && o == null) {
//				fail("XPath.selectSingleNode() returned nothing, but it should " +
//						"have returned " + expect[0]);
//			}
//			if (expect.length > 0 && o != expect[0]) {
//				fail("XPath.selectSingleNode() was expected to return " + 
//						expect[0] + "' but instead it returned '" + o + "'");
//			}
			
		} catch (JDOMException e) {
			e.printStackTrace();
			fail("Could not process XPath '" + xpath + 
					"'. Failed with: " + e.getClass() + 
					": " + e.getMessage());
		}
	}
	
	private void checkXPath(String xpath, Object context, String value, Object...expect) {
		checkXPath(setupXPath(xpath, null), context, value, null, expect);
	}

	private void checkComplexXPath(String xpath, Object context, Map<String, Object> variables, 
			Collection<Namespace> namespaces, String value, Number number, Object...expect) {
		Namespace[] nsa = namespaces == null ? new Namespace[0] : namespaces.toArray(new Namespace[0]);
		checkXPath(setupXPath(xpath, variables, nsa), context, value, number, expect);
	}

//	@Test
//	public void testSerialization() {
//		XPath xpath = setupXPath("//main", null);
//		XPath xser  = UnitTestUtil.deSerialize(xpath);
//		assertTrue(xpath != xser);
//		// TODO JaxenXPath has useless equals(). See issue #43
//		// Additionally, all XPath deserialization is done on the default
//		// factory... will never be equals() if the factory used to create
//		// the xpath is different.
//		// UnitTestUtil.checkEquals(xpath, xser);
//		assertEquals(xpath.toString(), xser.toString());
//	}
	
	@Theory
	public void autoPutTest(Fixture fixture) {
		checkXPath(_input.fixture, main, mainvalue, doc);
	}

	

		
	/* *************************************
	 * Boolean/Double/String tests.
	 * ************************************* */
	
	@Test
	public void getXPathDouble() {
		checkXPath("count( //* )", doc, null, Double.valueOf(4));
	}

	@Test
	public void getXPathString() {
		checkXPath("string( . )", child1emt, null, child1text.getText());
	}

	@Test
	public void getXPathBoolean() {
		checkXPath("count (//*) > 1", child1emt, null, Boolean.TRUE);
	}

	/* *************************************
	 * Element tests.
	 * ************************************* */
	
	@Test
	public void getXPathElementName() {
		checkXPath("//*[name() = 'main']", doc, null, main);
	}

	@Test
	public void getXPathElementText() {
		checkXPath("//*[string() = 'child1text']", doc, null, child1emt);
	}

	
	/* *************************************
	 * Processing Instruction tests.
	 * ************************************* */
	
	@Test
	public void getXPathProcessingInstructionAll() {
		checkXPath("//processing-instruction()", doc, null, docpi, mainpi);
	}

	@Test
	public void getXPathProcessingInstructionByTarget() {
		checkXPath("//processing-instruction()[name() = 'jdomtest']", doc, null, docpi, mainpi);
	}

	@Test
	public void getXPathProcessingInstructionByData() {
		checkXPath("//processing-instruction()[string() = 'doc']", doc, null, docpi);
	}

	/* *************************************
	 * Attribute tests.
	 * ************************************* */
	
	@Test
	@Ignore
	public void getXPathAttributeAll() {
		checkXPath("//@*", doc, null, mainatt, child3attint, child3attdoub);
	}

	@Test
	public void getXPathAttributeByName() {
		checkXPath("//@*[name() = 'atta']", doc, null, mainatt);
	}

	@Test
	public void getXPathAttributeByValue() {
		checkXPath("//@*[string() = '-123']", doc, null, child3attint);
	}

	/* *************************************
	 * XPath Variable tests.
	 * ************************************* */

	
	
	/* *******************************
	 * Axis TestCases
	 * ******************************* */
	
	
	
	
	
	
	/* *******************************
	 * Negative TestCases
	 * ******************************* */
	
	private static String INPUT1 = "/";

	private static String EXPECTED1 = null;

	private static String INPUT2 = "ancestor::node()";

	private static String EXPECTED2 = null;

	@DataPoints public static Fixture[] DATA={new Fixture(INPUT1,EXPECTED1),new Fixture(INPUT2,EXPECTED2)};

	public static class Fixture {
		private String _input;
		private Object _expected;

		public Fixture(String _input, Object _expected) {
			this._input = _input;
			this._expected = _expected;
		}
	}

}